<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Editor de diagramas</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <style id="dynamic-print-style"></style>

  <style>
    :root {
      --color-primary-accent: #3b82f6;
      --color-selection: #3b82f6;
      --color-connection: #60a5fa;
      --color-group-border: #a5b4fc;
      --color-group-bg: rgba(165, 180, 252, 0.05);
      --color-node-border-editing: #3b82f6;
    }

    body {
      display: flex; flex-direction: column; height: 100vh; width: 100vw;
      margin: 0; padding: 0; overflow: hidden; background-color: #f9fafb;
      font-family: sans-serif; -webkit-user-select: none; user-select: none;
    }
    #canvas {
      flex-grow: 1; position: relative; overflow-y: scroll; overflow-x: auto;
      background-color: #f9fafb; cursor: default; width: 100%; scroll-padding-top: 70px;
    }
    #panZoomContainer {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      transform-origin: 0 0; transition: transform 0.15s ease-out;
    }
    #page-guide-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
    #container { position: relative; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
    #svg-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
    #svg-container g.connection-group { pointer-events: all; }

    .node {
      padding: 0.5rem; background: white; border: 1px solid #e5e7eb; border-radius: 0.5rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      position: absolute; min-width: 100px; min-height: 40px; cursor: grab;
      display: flex; /* Changed to flex */
      align-items: center; /* Default vertical alignment */
      justify-content: center; /* Default horizontal alignment */
      overflow: hidden;
      overflow-wrap: break-word; word-wrap: break-word; hyphens: auto;
      transition: background-color 0.2s, border-color 0.2s, border-width 0.2s, border-radius 0.3s, box-shadow 0.2s, transform 0.2s;
      pointer-events: all;
    }
    .node.node-image {
        padding: 0;
    }
    .node .node-image-content {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      transition: filter 0.2s, opacity 0.2s;
    }

    .node .content { outline: none; width: 100%; min-height: 1.2em; pointer-events: none; text-align: center; transition: font-size: 0.2s; }
    .node .content ul { text-align: left; list-style-position: outside; padding-left: 1.5em; margin-left: 0; }
    .node .content li { margin-bottom: 0.2em; }
    .node .content b, .node .content strong { font-weight: bold; }
    .node .content i, .node .content em { font-style: italic; }
    .node.editing .content { pointer-events: auto; user-select: text; }
    .node.editing .connector { opacity: 0 !important; pointer-events: none !important; } //Oculta os conectores quando o nó pai está em modo de edição de texto
    .node.dragging { cursor: grabbing; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); z-index: 1000; }
    .node.editing, .node.style-target { cursor: default; border-color: var(--color-node-border-editing); }
    .node.selected, .group-container.selected {
        border-color: var(--color-selection);
        box-shadow: 0 0 0 3px color-mix(in srgb, var(--color-selection) 60%, transparent);
    }
    .node:not(.in-group):hover .connector { opacity: 1; transition: opacity 0.2s; }
    .node:not(.in-group):hover .connector.center { opacity: 0.4; }

    .connector { opacity: 0; z-index: 5; pointer-events: all; transition: opacity 0.2s ease, background-color 0.2s, box-shadow 0.2s, transform 0.15s; }
    .node.in-group .connector { opacity: 0 !important; pointer-events: none !important; }

    .connector { width: 18px; height: 18px; background: var(--color-primary-accent); border: 2px solid white; border-radius: 9999px; position: absolute; cursor: crosshair; box-shadow: 0 0 0 1px rgba(0,0,0,0.1); }
    .connector.top { top: -11px; left: 50%; transform: translateX(-50%); }
    .connector.bottom { bottom: -11px; left: 50%; transform: translateX(-50%); }
    .connector.left { left: -11px; top: 50%; transform: translateY(-50%); }
    .connector.right { right: -11px; top: 50%; transform: translateY(-50%); }
    .connector.center { top: 50%; left: 50%; transform: translate(-50%, -50%); }
    .connector.center.snap-target { transform: translate(-50%, -50%) scale(1.4); }

    .connector.snap-target {
        background-color: #22c55e;
        box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.4);
        transform: scale(1.4);
    }
    .connector.top.snap-target, .connector.bottom.snap-target { transform: translateX(-50%) scale(1.4); }
    .connector.left.snap-target, .connector.right.snap-target { transform: translateY(-50%) scale(1.4); }

    /* --- ESTILOS DE REDIMENSIONAMENTO E ALINHAMENTO (NOVO E ATUALIZADO) --- */
    .resize-handles-container {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none;
        z-index: 1002;
    }

    .resize-handle {
        position: absolute;
        width: 12px;
        height: 12px;
        background: var(--color-primary-accent);
        border: 2px solid white;
        border-radius: 3px;
        pointer-events: all;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    /* Posicionamento das 8 alças */
    .resize-handle.tl { top: -7px; left: -7px; cursor: nwse-resize; }
    .resize-handle.tm { top: -7px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
    .resize-handle.tr { top: -7px; right: -7px; cursor: nesw-resize; }
    .resize-handle.ml { top: 50%; left: -7px; transform: translateY(-50%); cursor: ew-resize; }
    .resize-handle.mr { top: 50%; right: -7px; transform: translateY(-50%); cursor: ew-resize; }
    .resize-handle.bl { bottom: -7px; left: -7px; cursor: nesw-resize; }
    .resize-handle.bm { bottom: -7px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
    .resize-handle.br { bottom: -7px; right: -7px; cursor: nwse-resize; }

    /* Estilo para as linhas-guia */
    .alignment-guide {
        stroke: #ff4d4d;
        stroke-width: 1px;
        stroke-dasharray: 4, 4;
        vector-effect: non-scaling-stroke;
    }

    /* Toolbar Styles Start */
    #toolbar, #connection-toolbar {
      position: absolute; display: flex; flex-direction: column;
      align-items: flex-start; gap: 0.3rem;
      background: white; border: 1px solid #ddd; border-radius: 0.5rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1); visibility: hidden; z-index: 1010;
      padding: 0.5rem;
      width: 330px;
    }
    .toolbar-row, .context-menu-row { display: flex; align-items: center; gap: 0.3rem; width: 100%; padding: 0 0.25rem;}
    .toolbar-label, .context-menu-label { font-size: 0.75rem; color: #6b7280; margin-right: 0.25rem; white-space: nowrap; }
    #toolbar button, #toolbar select, #toolbar input, #multiSelectToolbar button, #multiSelectToolbar select, #multiSelectToolbar input, #connection-toolbar button, #connection-toolbar input, #group-context-menu button, #group-context-menu select, #group-context-menu input {
        margin: 0; height: 32px; border-radius: 0.25rem; border: 1px solid #ccc;
        background: #fff; cursor: pointer; display: inline-flex;
        align-items: center; justify-content: center; box-sizing: border-box;
    }
    #toolbar button:hover, #toolbar select:hover, #multiSelectToolbar button:hover, #multiSelectToolbar select:hover, #connection-toolbar button:hover, #connection-toolbar input:hover, #group-context-menu button:hover, #group-context-menu select:hover, #group-context-menu input:hover { background-color: #f3f4f6; }
    #toolbar button, #connection-toolbar button, #group-context-menu button { width: 32px; padding: 0; }
    #toolbar button > svg { width: 1em; height: 1em; }
    #toolbar select, #group-context-menu select { padding: 0 0.5rem; }
    #toolbar input[type="color"], #multiSelectToolbar input[type="color"], #connection-toolbar input[type="color"], #group-context-menu input[type="color"] { width: 32px; padding: 2px; }
    #toolbar input[type="number"], #multiSelectToolbar input[type="number"], #connection-toolbar input[type="number"] { width: 50px; padding: 0.3rem; text-align: center; }
    #toolbar .separator, #connection-toolbar .separator, #group-context-menu .separator { width: 1px; height: 20px; background-color: #e5e7eb; margin: 0 0.4rem; }
    #toolbar .palette, #multiSelectToolbar .palette, #connection-toolbar .palette, #group-context-menu .palette { display: flex; align-items: center; gap: 0.2rem; }
    .color-swatch { width: 20px; height: 20px; border: 1px solid #ccc; cursor: pointer; border-radius: 9999px; }
    .drag-handle { cursor: move; user-select: none; }
    /* Toolbar Styles End */

    #group-context-menu {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0.5rem;
      width: 280px;
      background: white;
      border: 1px solid #ddd;
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      z-index: 1012;
      padding: 0.5rem;
    }
    #group-context-menu.hidden {
        display: none;
    }
    #group-context-menu .context-menu-row { gap: 0.5rem; }
    #group-context-menu hr { width: 95%; margin: 0.25rem auto; border: none; border-top: 1px solid #e5e7eb; }

    .node-ellipse { border-radius: 50% !important; }
    .node-rounded-xl { border-radius: 1.5rem !important; }
    .node-pill { border-radius: 9999px !important; }

    .group-container {
        position: absolute;
        border: 2px dashed var(--color-group-border);
        border-radius: 12px;
        background-color: var(--color-group-bg);
        pointer-events: all; z-index: 9;
        transition: background-color 0.2s, border-color 0.2s, border-style 0.2s, border-width 0.2s, box-shadow 0.2s, left 0.05s linear, top 0.05s linear;
    }
    .group-container.style-target { border-color: var(--color-primary-accent); }
    .group-container.dragging { cursor: grabbing; transition: none; }

    #marquee { position: absolute; border: 1px dashed #09f; background: rgba(0, 153, 255, 0.1); visibility: hidden; pointer-events: none; z-index: 2000; }
    #a4PageGuideRect { fill: white; stroke: #cccccc; vector-effect: non-scaling-stroke; stroke-width: 1; pointer-events: none; }

    .menu-item-button { display: block; width: 100%; text-align: left; padding: 0.5rem 1rem; font-size: 0.875rem; color: #374151; border-radius: 0.375rem; background-color: transparent; border: none; cursor: pointer; }
    .menu-item-button:hover { background-color: #e1e4eb; color: #1f2937; }
    .menu-item-button:disabled { color: #9ca3af; cursor: not-allowed; background-color: transparent; }
    .menu-icon-button { padding: 0.5rem; margin: 0.125rem; border: 1px solid #d1d5db; border-radius: 0.375rem; background-color: #f9fafb; transition: background-color 0.15s; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; width: 36px; height: 36px; }
    .menu-icon-button:hover:not(:disabled) { background-color: #e5e7eb; }
    .menu-icon-button:disabled { background-color: #f3f4f6; color: #9ca3af; cursor: not-allowed; }
    .menu-icon-button svg { width: 1.25em; height: 1.25em; }


    /* Modal Styles */
    #modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.5); display: flex;
      align-items: center; justify-content: center; z-index: 9999;
      opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s;
    }
    #modal-overlay.visible { opacity: 1; visibility: visible; }
    #modal-box {
      background: white; padding: 2rem; border-radius: 0.5rem;
      box-shadow: 0 10px 25px rgba(0,0,0,0.1); text-align: center;
      max-width: 90%; width: 400px;
      transform: scale(0.95); transition: transform 0.2s;
    }
    #modal-overlay.visible #modal-box { transform: scale(1); }
    #modal-content { margin-bottom: 1.5rem; color: #374151; }
    #modal-close-btn {
      background-color: var(--color-primary-accent); color: white; border: none;
      padding: 0.6rem 1.5rem; border-radius: 0.375rem; font-weight: 600;
      cursor: pointer; transition: background-color 0.2s;
    }
    #modal-close-btn:hover { background-color: color-mix(in srgb, var(--color-primary-accent) 85%, black); }

    @media print {
      body > #main-content-area > div:first-child, body > #main-content-area > #toolbar, body > #toolbar, body > #simpleModal, body #page-guide-container, #modal-overlay, #multiSelectToolbar, #connection-toolbar, #group-context-menu { display: none !important; }
      body > #main-content-area { margin-left: 0 !important; width: 100% !important; height: 100% !important; }
      #canvas { flex-grow: 0 !important; width: 100% !important; height: 100% !important; overflow: hidden !important; position: absolute !important; top: 0 !important; left: 0 !important; background-color: #ffffff !important; margin-left: 0 !important; scroll-padding-top: 0 !important; }
      #panZoomContainer { transform-origin: 0 0 !important; }
      svg#lines, #svg-container { width: 100% !important; height: 100% !important; overflow: hidden !important; }
    }

    /* --- ESTILO PARA A BARRA DE INFORMAÇÕES DO ARQUIVO --- */
    #file-info-bar {
    display: none; /* Começa escondida */
    position: sticky;
    top: 0;
    width: 100%;
    background-color: #1f2937; /* Cor escura para contraste */
    color: #d1d5db; /* Cor de texto cinza claro */
    padding: 4px 15px;
    text-align: center;
    font-size: 0.8rem;
    font-family: monospace;
    z-index: 1025; /* Garante que fique acima do menu principal */
    border-bottom: 1px solid #4b5563;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    }

  </style>
</head>
<body style="margin: 0; padding: 0; overflow: hidden; background-color: #f9fafb; font-family: sans-serif; -webkit-user-select: none; user-select: none;">
  
  <div id="file-info-bar">
    <span id="file-info-text"></span>
  </div>
  
  <div id="main-content-area" style="width: 100%; height: 100vh; display: flex; flex-direction: column;">
    <div class="flex justify-center w-full">
      <div id="top-buttons-container" class="flex items-center flex-wrap p-2.5 bg-gray-100 shadow-md space-x-2">
        <button id="addNode" class="px-4 py-2 bg-blue-500 text-white rounded-md shadow hover:bg-blue-800 transition text-sm font-semibold" title="Novo Item">Novo Item</button>
        <button id="addImageBtn"
                class="px-4 py-2 bg-green-500 text-white rounded-md shadow hover:bg-green-700 transition text-sm font-semibold"
                title="Adicionar Imagem">
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <circle cx="8.5" cy="8.5" r="1.5"></circle>
            <polyline points="21 15 16 10 5 21"></polyline>
        </svg>
        </button>
        <input type="file" id="imageUploadInput" accept="image/*" style="display: none;" />
        <button id="undoBtn" title="Desfazer (Ctrl+Z)" class="px-3 py-2 bg-gray-200 text-gray-400 rounded-md shadow hover:bg-red-600 transition text-sm" disabled>↩️</button>
        <button id="redoBtn" title="Refazer (Ctrl+Y)" class="px-3 py-2 bg-gray-200 text-gray-400 rounded-md shadow hover:bg-red-600 transition text-sm" disabled>↪️</button>
        <button id="deleteBtn" title="Deletar Selecionados (Delete)" class="px-3 py-2 bg-gray-200 text-gray-400 rounded-md shadow hover:bg-red-600 transition text-sm">🗑️</button>

        <button id="eyedropperBtn" class="p-2 bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-100 transition" title="Selecionar Cor da Tela">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="m13 2-3 3a2 2 0 0 0 0 2.828L12.828 12a2 2 0 0 0 2.828 0L21 6.828a2 2 0 0 0 0-2.828L18 1l-5 5-2-2Z"></path>
                <path d="m7.344 12.656-5.52 5.52a2.828 2.828 0 0 0 4 4l5.52-5.52"></path>
            </svg>
        </button>

        <div class="relative inline-block text-left">
            <button type="button" class="menu-trigger-button inline-flex items-center justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none">Arquivo<svg class="-mr-1 ml-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg></button>
            <div class="dropdown-panel hidden origin-top-left absolute left-0 mt-2 w-auto min-w-[160px] rounded-md shadow-xl bg-white ring-1 ring-black ring-opacity-5 z-[1015]">
                <div class="py-1">
                    <button id="saveDiagram" class="menu-item-button" title="Salvar alterações no arquivo atual (Ctrl+S)">💾 Salvar</button>
                    <button id="saveAsDiagram" class="menu-item-button" title="Salvar diagrama em um novo arquivo">💾 Salvar Como...</button>
                    
                    <label for="loadDiagramTrigger" id="loadDiagramLabel" class="menu-item-button" title="Carregar Diagrama">📂 Carregar</label>
                    
                    <label for="importDiagramInput" class="menu-item-button" title="Importar JSON para o diagrama atual">📥 Importar</label>
                    <input type="file" id="importDiagramInput" accept=".json,application/json" style="display: none;">
                    
                    <button id="printToPDFBtn" title="Imprimir para PDF" class="menu-item-button">🖨️ Imprimir PDF</button>
                    <button id="exportToPNGBtn" class="menu-item-button">🖼️ Exportar PNG</button>
                </div>
            </div>
        </div>

        <div class="relative inline-block text-left">
            <button type="button" class="menu-trigger-button inline-flex items-center justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none">Editar<svg class="-mr-1 ml-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg></button>
            <div class="dropdown-panel hidden origin-top-left absolute left-0 mt-2 w-auto min-w-[220px] rounded-md shadow-xl bg-white ring-1 ring-black ring-opacity-5 z-[1015]">
                <div class="py-1">
                    <button id="copyFormattingBtn" class="menu-item-button" title="Copiar estilo do nó (forma, cor, borda)">🎨 Copiar Estilo do Nó</button>
                    <button id="pasteFormattingBtn" class="menu-item-button" title="Aplicar estilo do nó copiado">📋 Colar Estilo do Nó</button>
                    <hr class="my-1 border-gray-200">
                    <button id="copyTextFormattingBtn" class="menu-item-button" title="Copiar formatação do texto (negrito, itálico, cor)">📝 Copiar Formatação do Texto</button>
                    <button id="pasteTextFormattingBtn" class="menu-item-button" title="Aplicar formatação de texto copiada">✍️ Colar Formatação do Texto</button>
                </div>
            </div>
        </div>

        <div class="relative inline-block text-left">
            <button type="button" class="menu-trigger-button inline-flex items-center justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none">Layout<svg class="-mr-1 ml-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg></button>
            <div id="layout-menu" class="dropdown-panel hidden origin-top-left absolute left-0 mt-2 w-auto min-w-[220px] rounded-md shadow-xl bg-white ring-1 ring-black ring-opacity-5 z-[1015]">
                <div class="py-1">
                    <button data-layout="hierarchical-tb" class="menu-item-button !py-2">Hierárquico (Vertical)</button>
                    <button data-layout="hierarchical-lr" class="menu-item-button !py-2">Hierárquico (Horizontal)</button>
                    <hr class="my-1 border-gray-200">
                    <button data-layout="force" class="menu-item-button !py-2">✨ Força-Dirigida</button>
                </div>
            </div>
        </div>

        <div class="relative inline-block text-left">
            <button type="button" class="menu-trigger-button inline-flex items-center justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none">Página<svg class="-mr-1 ml-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg></button>
            <div id="page-menu" class="dropdown-panel hidden origin-top-left absolute left-0 mt-2 w-auto min-w-[280px] rounded-md shadow-xl bg-white ring-1 ring-black ring-opacity-5 z-[1015] p-3 space-y-3">
                <div class="flex items-center justify-between"><label for="pageSizeSelect" class="text-sm text-gray-700 whitespace-nowrap mr-2">Tamanho:</label><select id="pageSizeSelect" class="text-sm p-1.5 border border-gray-300 rounded-md bg-white w-full"><option value="A4">A4 (21 x 29.7 cm)</option><option value="A5">A5 (14.8 x 21 cm)</option><option value="A3">A3 (29.7 x 42 cm)</option><option value="Letter">Carta (21.6 x 27.9 cm)</option><option value="custom">Personalizado</option></select></div>
                <div class="flex items-center justify-between"><label for="pageOrientationSelect" class="text-sm text-gray-700 whitespace-nowrap mr-2">Orientação:</label><select id="pageOrientationSelect" class="text-sm p-1.5 border border-gray-300 rounded-md bg-white w-full"><option value="portrait">Retrato</option><option value="landscape">Paisagem</option></select></div>
                <div id="custom-size-inputs" class="hidden space-y-3 pt-2"><hr><div class="flex items-center justify-between"><label for="pageCustomWidth" class="text-sm text-gray-700 whitespace-nowrap mr-2">Largura (px):</label><input type="number" id="pageCustomWidth" value="794" class="w-24 text-sm p-1 border border-gray-300 rounded-md text-center"></div><div class="flex items-center justify-between"><label for="pageCustomHeight" class="text-sm text-gray-700 whitespace-nowrap mr-2">Altura (px):</label><input type="number" id="pageCustomHeight" value="1123" class="w-24 text-sm p-1 border border-gray-300 rounded-md text-center"></div></div><hr>
                <button id="applyPageSettings" class="w-full mt-2 px-3 py-1.5 bg-indigo-500 text-white rounded-md shadow-sm hover:bg-indigo-600 transition text-sm font-semibold">Aplicar</button>
            </div>
        </div>
        <div class="relative inline-block text-left">
            <button type="button" class="menu-trigger-button inline-flex items-center justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none">Zoom<svg class="-mr-1 ml-2 h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg></button>
            <div class="dropdown-panel hidden origin-top-left absolute left-0 mt-2 w-auto min-w-[200px] rounded-md shadow-xl bg-white ring-1 ring-black ring-opacity-5 z-[1015]">
                <div class="py-1"><button id="zoomInBtnManual" title="Aumentar Zoom (+)" class="menu-item-button font-bold">＋ Aumentar Zoom</button><button id="zoomOutBtnManual" title="Diminuir Zoom (-)" class="menu-item-button font-bold">－ Diminuir Zoom</button><button id="zoomResetBtnManual" title="Restaurar Zoom (100%)" class="menu-item-button">💯 Restaurar Zoom</button><hr class="my-1 border-gray-200"><button id="fitToContentBtn" title="Ajustar ao Conteúdo" class="menu-item-button">🎯 Ajustar ao Conteúdo</button><button id="fitToPageBtn" title="Ajustar à Página" class="menu-item-button">📄 Ajustar à Página</button></div>
            </div>
        </div>
        <span id="zoomLevelDisplay" class="text-sm text-gray-700 self-center bg-gray-100 px-2 py-1 rounded-md shadow-sm">Zoom: 100%</span>
      </div>
    </div>
    <div id="canvas">
      <div id="panZoomContainer">
        <div id="page-guide-container">
            <svg width="100%" height="100%" style="overflow: visible !important;">
                <rect id="a4PageGuideRect" x="0" y="0" width="794" height="1123" />
            </svg>
        </div>
        <div id="container"></div>
        <div id="svg-container">
          <!-- NOVO: SVG para as linhas-guia de alinhamento -->
          <svg id="alignment-guides-svg" width="100%" height="100%" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 4; overflow: visible !important;"></svg>
          <svg id="lines" width="100%" height="100%" style="overflow: visible !important;"></svg>
        </div>
      </div>
    </div>
  </div>

  <div id="toolbar">
    <div id="toolbar-header" class="drag-handle w-full text-center text-gray-400 py-1" title="Arrastar painel">⠿</div>
    <div class="toolbar-row" data-toolbar-section="text-format">
        <button data-cmd="bold" title="Negrito"><b>B</b></button>
        <button data-cmd="italic" title="Itálico"><i>I</i></button>
        <button data-cmd="underline" title="Sublinhado"><u>U</u></button>
        <div class="separator"></div>
        <button data-cmd="superscript" title="Sobrescrito">X<sup>2</sup></button>
        <button data-cmd="subscript" title="Subscrito">X<sub>2</sub></button>
        <div class="separator"></div>
        <button data-cmd="removeFormat" title="Remover Formatação">T🧹</button>
    </div>
    <div class="toolbar-row" data-toolbar-section="text-align">
        <button data-textalign="left" title="Alinhar à Esquerda"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M2 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm0-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/></svg></button>
        <button data-textalign="center" title="Centralizar"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-2-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm2-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-2-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/></svg></button>
        <button data-textalign="right" title="Alinhar à Direita"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M6 12.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-4-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5zm4-3a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-4-3a.5.5 0 0 1 .5-.5h11a.5.5 0 0 1 0 1h-11a.5.5 0 0 1-.5-.5z"/></svg></button>
        <div class="separator"></div>
        <button data-cmd="insertUnorderedList" title="Lista" style="font-size: 1.25em; line-height: 1; padding: 0.1rem 0.5rem;">•</button>
    </div>
    <div class="toolbar-row" data-toolbar-section="vertical-align">
        <button data-verticalalign="flex-start" title="Alinhar ao Topo">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-align-top" viewBox="0 0 16 16" style="transform: rotate(-90deg);">
                <path d="M1.5 13a.5.5 0 0 0 0 1h13a.5.5 0 0 0 0-1h-13zM4 1.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zM8 6a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-1 0v-5A.5.5 0 0 1 8 6z"/>
            </svg>
        </button>
        <button data-verticalalign="center" title="Alinhar ao Meio">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-align-center" viewBox="0 0 16 16" style="transform: rotate(-90deg);">
                 <path d="M1.5 13a.5.5 0 0 0 0 1h13a.5.5 0 0 0 0-1h-13zm4-12a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zM8 4a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-1 0v-5A.5.5 0 0 1 8 4z"/>
            </svg>
        </button>
        <button data-verticalalign="flex-end" title="Alinhar à Base">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-align-bottom" viewBox="0 0 16 16" style="transform: rotate(-90deg);">
                <path d="M1.5 3a.5.5 0 0 1 0-1h13a.5.5 0 0 1 0 1h-13zM4 14.5a.5.5 0 0 0 .5.5h7a.5.5 0 0 0 0-1h-7a.5.5 0 0 0-.5.5zM8 6a.5.5 0 0 0-.5.5v5a.5.5 0 0 0 1 0v-5A.5.5 0 0 0 8 6z"/>
            </svg>
        </button>
    </div>
    <div class="toolbar-row" data-toolbar-section="text-style">
        <select data-cmd="fontSize" title="Tamanho da Fonte"><option value="3">Normal</option><option value="5">Grande</option><option value="2">Pequeno</option><option value="1">Muito pequeno</option><option value="7">Enorme</option></select>
        <select data-style="lineHeight" title="Espaçamento entre Linhas">
            <option value="normal">Normal</option>
            <option value="0.8">Compacto</option>
            <option value="1">Simples</option>
            <option value="1.5">1.5</option>
            <option value="2">Duplo</option>
        </select>
    </div>
    <div class="toolbar-row" data-toolbar-section="text-color">
        <span class="toolbar-label">Texto:</span>
        <div id="palette-text" class="palette">
          <div class="color-swatch" style="background:#000000" data-color="#000000" title="Preto"></div>
          <div class="color-swatch" style="background:#1A4F63" data-color="#1A4F63" title="Azul Escuro"></div>
          <div class="color-swatch" style="background:#068587" data-color="#068587" title="Verde Água"></div>
          <div class="color-swatch" style="background:#6FB07F" data-color="#6FB07F" title="Verde"></div>
          <div class="color-swatch" style="background:#FCB03C" data-color="#FCB03C" title="Laranja"></div>
        </div>
        <input type="color" id="customColor" title="Cor da Fonte Customizada"/>
        <input type="text" id="customColorHex" class="hex-color-input" title="Código Hex da Cor do Texto" size="7" maxlength="7" style="font-family: monospace; width: 65px; text-align: center; height: 32px; border-radius: 0.25rem; border: 1px solid #ccc;"/>
    </div>
    <div class="toolbar-row" data-toolbar-section="background">
        <span class="toolbar-label">Fundo:</span>
        <div id="palette-bg" class="palette">
          <div class="color-swatch" style="background:#FFFFFF" data-color="#FFFFFF" title="Branco"></div>
          <div class="color-swatch" style="background:#EFF6FF" data-color="#EFF6FF" title="Azul Claro"></div>
          <div class="color-swatch" style="background:#FEFCE8" data-color="#FEFCE8" title="Amarelo Claro"></div>
          <div class="color-swatch" style="background:#F0FDF4" data-color="#F0FDF4" title="Verde Claro"></div>
        </div>
        <input type="color" data-style="backgroundColor" value="#FFFFFF" title="Cor do Fundo">
        <input type="text" data-style-hex="backgroundColor" class="hex-color-input" title="Código Hex da Cor do Fundo" size="7" maxlength="7" style="font-family: monospace; width: 65px; text-align: center; height: 32px; border-radius: 0.25rem; border: 1px solid #ccc;"/>
        <button data-style="transparent" title="Fundo Transparente">👻</button>
    </div>
    <div class="toolbar-row" data-toolbar-section="border-color">
        <span class="toolbar-label">Borda:</span>
        <div id="palette-border" class="palette">
          <div class="color-swatch" style="background:#E5E7EB" data-color="#E5E7EB" title="Cinza"></div>
          <div class="color-swatch" style="background:#3B82F6" data-color="#3B82F6" title="Azul"></div>
          <div class="color-swatch" style="background:#F59E0B" data-color="#F59E0B" title="Âmbar"></div>
           <div class="color-swatch" style="background:#10B981" data-color="#10B981" title="Esmeralda"></div>
        </div>
        <input type="color" data-style="borderColor" value="#E5E7EB" title="Cor da Borda">
        <input type="text" data-style-hex="borderColor" class="hex-color-input" title="Código Hex da Cor da Borda" size="7" maxlength="7" style="font-family: monospace; width: 65px; text-align: center; height: 32px; border-radius: 0.25rem; border: 1px solid #ccc;"/>
    </div>
     <div class="toolbar-row" data-toolbar-section="shape">
        <span class="toolbar-label">Largura:</span>
        <input type="number" data-style="borderWidth" min="0" max="15" value="1" title="Largura da Borda" style="width: 50px;">
        <div class="separator"></div>
        <span class="toolbar-label">Forma:</span>
        <select data-style="shape" title="Forma" style="flex-grow: 1;">
            <option value="rectangle">Retângulo</option>
            <option value="ellipse">Elipse</option>
            <option value="rounded-xl">Arredondado</option>
            <option value="pill">Pílula</option>
        </select>
    </div>
    <div class="toolbar-row flex-col items-start p-2 space-y-2" data-toolbar-section="image-style" style="display:none; width: 240px;">
        <div class="w-full flex items-center justify-between">
            <label for="imageObjectFit" class="toolbar-label !mr-0">Ajuste:</label>
            <select id="imageObjectFit" data-image-style="objectFit" class="text-sm p-1 border rounded w-[60%]">
            <option value="contain">Conter</option>
            <option value="cover">Preencher</option>
            <option value="fill">Esticar</option>
            <option value="scale-down">Reduzir</option>
            </select>
        </div>
        <div class="w-full">
            <label for="imageOpacity" class="toolbar-label">Opacidade:</label>
            <input type="range" id="imageOpacity" data-image-style="opacity" min="0" max="1" step="0.05" value="1" class="w-full">
        </div>
        <div class="w-full">
            <label for="imageBrightness" class="toolbar-label">Brilho:</label>
            <input type="range" id="imageBrightness" data-image-filter="brightness" min="0" max="2" step="0.1" value="1" class="w-full">
        </div>
        <div class="w-full">
            <label for="imageContrast" class="toolbar-label">Contraste:</label>
            <input type="range" id="imageContrast" data-image-filter="contrast" min="0" max="2" step="0.1" value="1" class="w-full">
        </div>
        <div class="w-full">
            <label for="imageSaturate" class="toolbar-label">Saturação:</label>
            <input type="range" id="imageSaturate" data-image-filter="saturate" min="0" max="2" step="0.1" value="1" class="w-full">
        </div>
        <hr class="w-full my-1">
        <button id="resetImageStylesBtn" class="w-full py-1 bg-gray-200 text-sm rounded hover:bg-gray-300">✨ Restaurar Padrão</button>
    </div>
  </div>

  <div id="multiSelectToolbar" class="p-3 bg-white shadow-lg rounded-lg border border-gray-300" style="position: absolute; visibility: hidden; z-index: 1011; display: flex; flex-direction: column; gap: 0.75rem; width: 330px;">
      <div id="multi-select-toolbar-header" class="drag-handle text-center text-gray-400 -mt-1 -mx-3 mb-1 py-1 bg-gray-50 rounded-t-lg border-b" title="Arrastar painel">⠿</div>
      <div class="-mt-3">
        <p class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">ESTILOS</p>
        <div class="space-y-3">

          <div class="toolbar-row flex items-center">
              <span class="toolbar-label">Fundo:</span>
              <div id="multi-palette-bg" class="palette">
                <div class="color-swatch" style="background:#FFFFFF" data-color="#FFFFFF" title="Branco"></div>
                <div class="color-swatch" style="background:#EFF6FF" data-color="#EFF6FF" title="Azul Claro"></div>
                <div class="color-swatch" style="background:#FEFCE8" data-color="#FEFCE8" title="Amarelo Claro"></div>
              </div>
              <input type="color" data-multi-style="backgroundColor" value="#FFFFFF" title="Cor do Fundo">
              <input type="text" data-multi-style-hex="backgroundColor" class="hex-color-input" title="Código Hex da Cor do Fundo" size="7" maxlength="7" style="font-family: monospace; width: 65px; text-align: center; height: 32px; border-radius: 0.25rem; border: 1px solid #ccc; flex-grow: 1;">
          </div>

          <div class="toolbar-row flex items-center">
              <span class="toolbar-label">Borda:</span>
              <div id="multi-palette-border" class="palette">
                <div class="color-swatch" style="background:#E5E7EB" data-color="#E5E7EB" title="Cinza"></div>
                <div class="color-swatch" style="background:#3B82F6" data-color="#3B82F6" title="Azul"></div>
                <div class="color-swatch" style="background:#EF4444" data-color="#EF4444" title="Vermelho"></div>
              </div>
              <input type="color" data-multi-style="borderColor" value="#E5E7EB" title="Cor da Borda">
              <input type="text" data-multi-style-hex="borderColor" class="hex-color-input" title="Código Hex da Cor da Borda" size="7" maxlength="7" style="font-family: monospace; width: 65px; text-align: center; height: 32px; border-radius: 0.25rem; border: 1px solid #ccc; flex-grow: 1;">
          </div>

          <div class="grid grid-cols-[auto_1fr_auto_1fr] gap-x-3 items-center">
              <label class="toolbar-label justify-self-start">Largura:</label>
              <input type="number" data-multi-style="borderWidth" min="0" max="15" value="1" title="Largura da Borda" class="w-full p-1 h-auto">
              <label class="toolbar-label justify-self-end">Forma:</label>
              <select data-multi-style="shape" title="Forma" class="w-full p-1 h-auto">
                  <option value="rectangle">Retângulo</option>
                  <option value="ellipse">Elipse</option>
                  <option value="rounded-xl">Arredondado</option>
                  <option value="pill">Pílula</option>
              </select>
          </div>
          <button id="applyBulkChanges" class="w-full mt-1 px-3 py-1.5 bg-yellow-400 text-black rounded-md shadow-sm hover:bg-yellow-500 transition text-sm font-semibold">Aplicar Estilos</button>
        </div>
      </div>

      <hr/>

      <div>
        <p class="text-xs font-bold text-gray-500 uppercase tracking-wider mb-2">ORGANIZAR</p>
        <div class="space-y-2">
            <div class="grid grid-cols-2 gap-2">
                <button data-action="group" class="menu-item-button !h-auto !py-1.5 !w-full !justify-center !inline-flex !items-center !border !border-gray-200" title="Agrupar Itens (Ctrl+G)">📦 Agrupar</button>
                <button data-action="ungroup" class="menu-item-button !h-auto !py-1.5 !w-full !justify-center !inline-flex !items-center !border !border-gray-200" title="Desagrupar Itens (Ctrl+Shift+G)">🖐️ Desagrupar</button>
            </div>
            <div class="grid grid-cols-6 gap-1">
                <button data-align="left" title="Alinhar à Esquerda" class="menu-icon-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M3 3h2v14H3V3zm4 2h10V3H7v2zm0 4h7V7H7v2zm0 4h10v-2H7v2zm0 4h7v-2H7v2z"/></svg></button>
                <button data-align="center-h" title="Centralizar Horizontal" class="menu-icon-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M9 3h2v14H9V3zM3 5h14V3H3v2zm2 4h10V7H5v2zm-2 4h14v-2H3v2zm2 4h10v-2H5v2z"/></svg></button>
                <button data-align="right" title="Alinhar à Direita" class="menu-icon-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path d="M15 3h2v14h-2V3zM3 5h10V3H3v2zm3 4h7V7H6v2zm-3 4h10v-2H3v2zm3 4h7v-2H6v2z"/></svg></button>
                <button data-align="top" title="Alinhar Acima" class="menu-icon-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" style="transform: rotate(-90deg);"><path d="M3 3h2v14H3V3zm4 2h10V3H7v2zm0 4h7V7H7v2zm0 4h10v-2H7v2zm0 4h7v-2H7v2z"/></svg></button>
                <button data-align="center-v" title="Centralizar Vertical" class="menu-icon-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" style="transform: rotate(-90deg);"><path d="M9 3h2v14H9V3zM3 5h14V3H3v2zm2 4h10V7H5v2zm-2 4h14v-2H3v2zm2 4h10v-2H5v2z"/></svg></button>
                <button data-align="bottom" title="Alinhar Abaixo" class="menu-icon-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true" style="transform: rotate(-90deg);"><path d="M15 3h2v14h-2V3zM3 5h10V3H3v2zm3 4h7V7H6v2zm-3 4h10v-2H3v2zm3 4h7v-2H6v2z"/></svg></button>
            </div>
            <div class="grid grid-cols-2 gap-2">
                <button data-distribute="horizontal" title="Distribuir Horizontalmente" class="menu-item-button text-base !w-full">↔️ Distribuir</button>
                <button data-distribute="vertical" title="Distribuir Verticalmente" class="menu-item-button text-base !w-full">↕️ Distribuir</button>
            </div>
        </div>
      </div>
  </div>

  <div id="group-context-menu" class="hidden">
      <div id="group-context-header" class="drag-handle text-center bg-gray-50 rounded-t-md -mb-1 py-1" title="Arrastar">
        <span style="font-size: 10px; color: #9ca3af;">⠿</span>
      </div>
      <div class="context-menu-row">
          <span class="context-menu-label">Fundo:</span>
          <div class="palette">
            <div class="color-swatch" style="background:#EFF6FF" data-color="#EFF6FF" title="Azul Claro"></div>
            <div class="color-swatch" style="background:#FEFCE8" data-color="#FEFCE8" title="Amarelo Claro"></div>
            <div class="color-swatch" style="background:#F0FDF4" data-color="#F0FDF4" title="Verde Claro"></div>
          </div>
          <input type="color" data-group-style="backgroundColor" title="Cor do Fundo">
          <button data-group-style="transparent" title="Fundo Transparente">👻</button>
      </div>
      <hr />
      <div class="context-menu-row">
        <span class="context-menu-label">Borda:</span>
        <div class="palette">
          <div class="color-swatch" style="background:#a5b4fc" data-color="#a5b4fc" title="Índigo Claro"></div>
          <div class="color-swatch" style="background:#F59E0B" data-color="#F59E0B" title="Âmbar"></div>
           <div class="color-swatch" style="background:#9ca3af" data-color="#9ca3af" title="Cinza"></div>
        </div>
        <input type="color" data-group-style="borderColor" title="Cor da Borda">
        <select data-group-style="borderStyle" title="Estilo da Borda" class="!w-auto flex-grow">
            <option value="dashed">Tracejada</option>
            <option value="solid">Sólida</option>
            <option value="dotted">Pontilhada</option>
            <option value="none">Sem Borda</option>
        </select>
      </div>
      <hr />
      <button id="context-ungroup-btn" class="menu-item-button !h-auto !py-1.5 !w-full !justify-center !inline-flex !items-center !gap-2 !border !border-gray-200">🖐️ Desagrupar</button>
  </div>

  <div id="connection-toolbar">
    <div id="connection-toolbar-header" class="drag-handle w-full text-center text-gray-400 py-1" title="Arrastar painel">⠿</div>
     <div class="toolbar-row">
        <span class="toolbar-label">Linha:</span>
        <div id="palette-connection" class="palette">
          <div class="color-swatch" style="background:#60a5fa" data-color="#60a5fa" title="Azul Padrão"></div>
          <div class="color-swatch" style="background:#34495e" data-color="#34495e" title="Cinza Escuro"></div>
          <div class="color-swatch" style="background:#f1c40f" data-color="#f1c40f" title="Amarelo"></div>
          <div class="color-swatch" style="background:#e74c3c" data-color="#e74c3c" title="Vermelho"></div>
        </div>
        <input type="color" data-conn-style="color" value="#60a5fa" title="Cor da Linha">
        <div class="separator"></div>
        <input type="number" data-conn-style="width" min="1" max="20" value="2.5" step="0.5" title="Largura da Linha">
    </div>
  </div>

  <div id="marquee"></div>

  <div id="modal-overlay">
    <div id="modal-box">
      <p id="modal-content">Sample message</p>
      <button id="modal-close-btn">OK</button>
    </div>
  </div>

  <div id="colorLoupe" style="position: absolute; width: 80px; height: 80px; border: 1px solid #ccc; border-radius: 50%; overflow: hidden; z-index: 1020; display: none; pointer-events: none;">
    <canvas id="loupeCanvas" width="200" height="200" style="transform: scale(0.4); transform-origin: top left;"></canvas>
  </div>

  <div id="color-picker-modal-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: none; align-items: center; justify-content: center; z-index: 1030;">
    <div id="color-picker-modal-box" style="background: white; padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 10px 25px rgba(0,0,0,0.1); display: flex; flex-direction: column; align-items: center; gap: 1rem;">
      <h3 style="margin: 0; font-size: 1.1rem; font-weight: 600; color: #374151;">Cor Selecionada</h3>
      <div style="display: flex; align-items: center; gap: 0.75rem; border: 1px solid #e5e7eb; padding: 0.5rem 1rem; border-radius: 0.375rem;">
        <div id="modalColorPreview" style="width: 2rem; height: 2rem; border: 1px solid #ccc; border-radius: 0.25rem;"></div>
        <div id="modalColorHexCode" style="font-size: 1.1rem; font-family: monospace; color: #1f2937; cursor: pointer; padding: 0.25rem;" title="Clique para copiar">#000000</div>
      </div>
    </div>
  </div>

    <div id="confirmation-modal-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 10000;">
        <div id="confirmation-modal-box" style="background: white; padding: 1.5rem 2rem; border-radius: 0.5rem; box-shadow: 0 10px 25px rgba(0,0,0,0.1); text-align: center; max-width: 90%; width: 450px;">
        <h3 id="confirmation-modal-title" style="margin-top: 0; margin-bottom: 1rem; color: #1f2937;">Deseja salvar as alterações?</h3>
        <p id="confirmation-modal-message" style="margin-bottom: 2rem; color: #4b5563; font-size: 0.9rem;">Você tem alterações não salvas no diagrama atual. O que você gostaria de fazer?</p>
        <div id="confirmation-modal-buttons" style="display: flex; justify-content: space-between; gap: 0.75rem;">
            <button id="confirm-cancel-btn" style="flex: 1; padding: 0.6rem; border: 1px solid #d1d5db; background: #fff; color: #374151; border-radius: 0.375rem; cursor: pointer; font-weight: 600;">Cancelar</button>
            <button id="confirm-discard-btn" style="flex: 1; padding: 0.6rem; border: none; background: #ef4444; color: white; border-radius: 0.375rem; cursor: pointer; font-weight: 600;">Descartar</button>
            <button id="confirm-save-btn" style="flex: 1; padding: 0.6rem; border: none; background: #2563eb; color: white; border-radius: 0.375rem; cursor: pointer; font-weight: 600;">Salvar e Continuar</button>
        </div>
        </div>
    </div>
  
  <script>
    // --- Global Elements ---
    const canvasEl = document.getElementById('canvas');
    const fileInfoBar = document.getElementById('file-info-bar');
    const fileInfoText = document.getElementById('file-info-text');
    const panZoomContainer = document.getElementById('panZoomContainer');
    const container = document.getElementById('container');
    const svg = document.getElementById('lines');
    const svgContainer = document.getElementById('svg-container');
    const a4PageGuideRect = document.getElementById('a4PageGuideRect');
    const toolbar = document.getElementById('toolbar');
    const multiSelectToolbar = document.getElementById('multiSelectToolbar');
    const connectionToolbar = document.getElementById('connection-toolbar');
    const applyBulkChangesBtn = document.getElementById('applyBulkChanges');
    const groupContextMenu = document.getElementById('group-context-menu');
    const contextUngroupBtn = document.getElementById('context-ungroup-btn');
    const marquee = document.getElementById('marquee');
    const customColorInput = document.getElementById('customColor');
    const addNodeButton = document.getElementById('addNode');
    const saveDiagramButton = document.getElementById('saveDiagram');
    const loadDiagramInput = document.getElementById('loadDiagramInput');
    const printToPDFBtn = document.getElementById('printToPDFBtn');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const fitToContentBtn = document.getElementById('fitToContentBtn');
    const fitToPageBtn = document.getElementById('fitToPageBtn');
    const zoomInBtnManual = document.getElementById('zoomInBtnManual');
    const zoomOutBtnManual = document.getElementById('zoomOutBtnManual');
    const zoomResetBtnManual = document.getElementById('zoomResetBtnManual');
    const zoomLevelDisplay = document.getElementById('zoomLevelDisplay');
    const deleteBtn = document.getElementById('deleteBtn');
    const pageSizeSelect = document.getElementById('pageSizeSelect');
    const pageOrientationSelect = document.getElementById('pageOrientationSelect');
    const customSizeInputs = document.getElementById('custom-size-inputs');
    const pageCustomWidth = document.getElementById('pageCustomWidth');
    const pageCustomHeight = document.getElementById('pageCustomHeight');
    const dynamicPrintStyle = document.getElementById('dynamic-print-style');
    const modalOverlay = document.getElementById('modal-overlay');
    const modalContent = document.getElementById('modal-content');
    const modalCloseBtn = document.getElementById('modal-close-btn');

    // --- Elemento Medidor de Texto  ---
    const textMeasurer = document.createElement('span');
    textMeasurer.style.position = 'absolute';
    textMeasurer.style.visibility = 'hidden';
    textMeasurer.style.whiteSpace = 'nowrap'; // Impede que o próprio medidor quebre a linha
    document.body.appendChild(textMeasurer);

    const addImageBtn = document.getElementById('addImageBtn');
    const imageUploadInput = document.getElementById('imageUploadInput');
    const copyFormattingBtn = document.getElementById('copyFormattingBtn');
    const pasteFormattingBtn = document.getElementById('pasteFormattingBtn');
    // NOVO: Referência para o SVG das guias
    const alignmentGuidesSvg = document.getElementById('alignment-guides-svg');


    // --- Lógica para tornar painéis arrastáveis ---
    function makeDraggable(draggableEl, handleEl) {
        let offsetX = 0, offsetY = 0;

        handleEl.onmousedown = function (e) {
            e.stopPropagation();

            if (e.target.closest('button, input, select, .palette')) return;
            e.preventDefault();

            offsetX = e.clientX - draggableEl.offsetLeft;
            offsetY = e.clientY - draggableEl.offsetTop;

            document.onmousemove = onMouseMove;
            document.onmouseup = onMouseUp;
        };

        function onMouseMove(e) {
            e.preventDefault();
            let newLeft = e.clientX - offsetX;
            let newTop = e.clientY - offsetY;

            const elRect = draggableEl.getBoundingClientRect();
            newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - elRect.width));
            newTop = Math.max(0, Math.min(newTop, window.innerHeight - elRect.height));

            draggableEl.style.left = newLeft + 'px';
            draggableEl.style.top = newTop + 'px';
        }

        function onMouseUp() {
            document.onmouseup = null;
            document.onmousemove = null;
        }
    }


    // --- Theme & Colors Configuration ---
    const themeColors = {
        primaryAccent: '#3b82f6',
        selection: '#3b82f6',
        connection: '#60a5fa',
        connectionSelected: '#2563eb',
        groupBorder: '#a5b4fc',
        get groupBg() { return hexToRgba(this.groupBorder, 0.05); },
        nodeBorderEditing: '#3b82f6'
    };

    // --- Constants ---
    const A4_WIDTH_PX = 794;
    const A4_HEIGHT_PX = 1123;
    const PAGE_SIZES_PX = { 'A4': { width: 794, height: 1123 }, 'A5': { width: 559, height: 794 }, 'A3': { width: 1123, height: 1587 }, 'Letter': { width: 816, height: 1056 }, };
    const PAGE_SIZES_PHYSICAL = { 'A4': { width: '210mm', height: '297mm' }, 'A5': { width: '148mm', height: '210mm' }, 'A3': { width: '297mm', height: '420mm' }, 'Letter': { width: '8.5in', height: '11in' }, };
    const A4_VIEW_PADDING = 20;
    const MIN_ZOOM_SCALE = 0.1;
    const MAX_ZOOM_SCALE = 5.0;
    const DRAG_THRESHOLD = 5;
    const KEY_MOVE_STEP = 10;
    const ZOOM_BUTTON_STEP_FACTOR = 1.2;
    const CONNECTOR_SNAP_RADIUS = 25;
    const SNAP_THRESHOLD = 5; // Tolerância em pixels para o alinhamento

    // --- State Variables ---
    let fileHandle = null;
    let isDirty = false;
    let isA4ModeActive = true;
    let viewport = { scale: 1.0, panX: 0, panY: 0 };
    let isPanning = false;
    let lastPanPosition = { x: 0, y: 0 };
    let globalScreenMouse = { x: 0, y: 0 };
    let undoStack = [];
    let redoStack = [];
    let nodeCounter = 0;
    let connections = [];
    let editingNode = null;
    let savedRange = null;
    let selectedItems = new Set();
    let selectedConnections = new Set();
    let actionState = { type: null, target: null, startX: 0, startY: 0, startWidth: 0, startHeight: 0, linkStartPos: null, isCtrl: false, moved: false, initialPositions: [] };
    let appClipboard = { type: null, items: [], anchor: { left: 0, top: 0 } };
    let formattingClipboard = null; // Para copiar/colar formatação de estilo
    let textFormattingClipboard = null; // Para copiar/colar a formatação do texto
    let currentLineColor = themeColors.connection;
    let currentLineStrokeWidth = 2.5;
    let globalNodeBackgroundColor = '#FFFFFF';
    let globalNodeBorderColor = '#E5E7EB';
    let globalNodeBorderWidth = 1;
    let globalNodeShape = 'rectangle';
    let originalViewportBeforePrint = null;
    let isLayoutRunning = false;
    let keyMoveUndoTimer = null;
    let initialKeyMovePositions = null;

    // --- Utility Functions ---
    function rgbToHex(rgb) {
        if (!rgb || rgb === 'transparent' || !rgb.startsWith('rgb')) return '#000000';
        const match = rgb.match(/\d+/g);
        if (!match) return '#000000';
        const [r, g, b] = match.map(Number);
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
    };
    function hexToRgba(hex, alpha) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (!result) return `rgba(0,0,0,${alpha})`;
        const r = parseInt(result[1], 16);
        const g = parseInt(result[2], 16);
        const b = parseInt(result[3], 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // --- Modal Logic ---
    function showModal(message) {
        modalContent.textContent = message;
        modalOverlay.classList.add('visible');
    }
    function hideModal() {
        modalOverlay.classList.remove('visible');
    }
    modalCloseBtn.addEventListener('click', hideModal);
    modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) hideModal();
    });
    
    // --- NOVA FUNÇÃO PARA O MODAL DE CONFIRMAÇÃO ---
    function showConfirmationModal() {
        return new Promise((resolve) => {
            const overlay = document.getElementById('confirmation-modal-overlay');
            const saveBtn = document.getElementById('confirm-save-btn');
            const discardBtn = document.getElementById('confirm-discard-btn');
            const cancelBtn = document.getElementById('confirm-cancel-btn');

            overlay.style.display = 'flex';

            const close = (choice) => {
                overlay.style.display = 'none';
                // Remove os listeners para não acumularem
                saveBtn.onclick = null;
                discardBtn.onclick = null;
                cancelBtn.onclick = null;
                resolve(choice);
            };

            saveBtn.onclick = () => close('save');
            discardBtn.onclick = () => close('discard');
            cancelBtn.onclick = () => close('cancel');
        });
    }

    // --- Menu Dropdown Logic ---
    document.addEventListener('DOMContentLoaded', () => {
        const menuTriggerButtons = document.querySelectorAll('.menu-trigger-button');
        const dropdownPanels = document.querySelectorAll('.dropdown-panel');
        menuTriggerButtons.forEach(button => { button.addEventListener('click', function(event) { event.stopPropagation(); const targetPanel = this.nextElementSibling; const wasOpen = targetPanel && !targetPanel.classList.contains('hidden'); dropdownPanels.forEach(panel => { panel.classList.add('hidden'); }); if (!wasOpen && targetPanel?.classList.contains('dropdown-panel')) { targetPanel.classList.remove('hidden'); } }); });
        document.addEventListener('click', function(event) { const clickedElement = event.target; let clickedOnTrigger = false; menuTriggerButtons.forEach(button => { if (button === clickedElement || button.contains(clickedElement)) clickedOnTrigger = true; }); if (clickedOnTrigger) return; let clickedInsideOpenPanel = false; dropdownPanels.forEach(panel => { if (!panel.classList.contains('hidden') && panel.contains(clickedElement)) clickedInsideOpenPanel = true; }); if (!clickedInsideOpenPanel) dropdownPanels.forEach(panel => panel.classList.add('hidden')); });
    });

    // --- Undo/Redo & State Management ---
    function updateUndoRedoButtons() { undoBtn.disabled = undoStack.length === 0; redoBtn.disabled = redoStack.length === 0; }

    function recordAction(action, fromUndo = false, fromRedo = false) {
        if (!fromUndo && !fromRedo) {
            undoStack.push(action);
            redoStack = [];
            isDirty = true; // <-- ADICIONE ESTA LINHA
        } else if (fromUndo) {
            redoStack.push(action);
        } else if (fromRedo) {
            undoStack.push(action);
        }
        updateUndoRedoButtons();
    }

    function getNodeDataForUndo(nodeEl) {
        const nodeData = {
            id: nodeEl.id,
            left: nodeEl.style.left,
            top: nodeEl.style.top,
            width: nodeEl.style.width || `${nodeEl.offsetWidth}px`,
            height: nodeEl.style.height || `${nodeEl.offsetHeight}px`,
            className: Array.from(nodeEl.classList).filter(c => !['selected', 'dragging', 'node', 'editing'].includes(c)).join(' '),
            inlineStyle: nodeEl.style.cssText,
        };

        const imageEl = nodeEl.querySelector('img.node-image-content');
        if (imageEl) {
            nodeData.type = 'image';
            nodeData.imageUrl = imageEl.src;
            nodeData.imageStyle = imageEl.style.cssText; // Captura estilos da imagem
        } else {
            const contentDiv = nodeEl.querySelector('.content');
            nodeData.type = 'text';
            nodeData.text = contentDiv.innerHTML;
            nodeData.contentTextAlign = contentDiv.style.textAlign || 'center';
            nodeData.contentLineHeight = contentDiv.style.lineHeight || 'normal';
            nodeData.alignItems = nodeEl.style.alignItems || 'center'; // Save vertical alignment
        }
        return nodeData;
    }

    // --- Viewport & Zoom ---
    function updateZoomDisplay() { if (zoomLevelDisplay) zoomLevelDisplay.textContent = `Zoom: ${Math.round(viewport.scale * 100)}%`; }
    function applyViewportTransform() { panZoomContainer.style.transform = `translate(${viewport.panX}px, ${viewport.panY}px) scale(${viewport.scale})`; drawLines(); updateSelectionVisuals(); }
    function screenToWorld(screenX, screenY) { const canvasRect = canvasEl.getBoundingClientRect(); return { x: (screenX - canvasRect.left - viewport.panX) / viewport.scale, y: (screenY - canvasRect.top - viewport.panY) / viewport.scale }; }
    function fitToContent(targetBounds = null) { const bounds = targetBounds || getDiagramBounds(); if (bounds.isEmpty && !targetBounds) { const pageW = parseFloat(a4PageGuideRect.getAttribute('width')); const pageH = parseFloat(a4PageGuideRect.getAttribute('height')); viewport.scale = Math.min(canvasEl.clientWidth / pageW, canvasEl.clientHeight / pageH) * 0.9; viewport.panX = (canvasEl.clientWidth / 2) - (pageW / 2) * viewport.scale; viewport.panY = (canvasEl.clientHeight / 2) - (pageH / 2) * viewport.scale; applyViewportTransform(); return; } const canvasWidth = canvasEl.clientWidth; const canvasHeight = canvasEl.clientHeight; const screenPadding = 20; const effectiveCanvasWidth = canvasWidth - (2 * screenPadding); const effectiveCanvasHeight = canvasHeight - (2 * screenPadding); let newScale; if (effectiveCanvasWidth <= 0 || effectiveCanvasHeight <= 0 || bounds.width <= 0 || bounds.height <= 0) newScale = 1.0; else newScale = Math.min(effectiveCanvasWidth / bounds.width, effectiveCanvasHeight / bounds.height); viewport.scale = Math.max(MIN_ZOOM_SCALE, Math.min(newScale, MAX_ZOOM_SCALE)); viewport.panX = (canvasWidth / 2) - (bounds.x + bounds.width / 2) * viewport.scale; viewport.panY = (canvasHeight / 2) - (bounds.y + bounds.height / 2) * viewport.scale; applyViewportTransform(); }
    function fitToA4PageGuide() { const currentWidth = parseFloat(a4PageGuideRect.getAttribute('width')); const currentHeight = parseFloat(a4PageGuideRect.getAttribute('height')); fitToContent({ x: 0, y: 0, width: currentWidth, height: currentHeight, isEmpty: false }); }
    function handleManualZoom(zoomIn) { const oldScale = viewport.scale; const oldPanX = viewport.panX; let newScale = zoomIn ? oldScale * ZOOM_BUTTON_STEP_FACTOR : oldScale / ZOOM_BUTTON_STEP_FACTOR; newScale = Math.max(MIN_ZOOM_SCALE, Math.min(newScale, MAX_ZOOM_SCALE)); viewport.scale = newScale; const screenCenterX = canvasEl.clientWidth / 2; const worldPointXAtScreenCenter = (screenCenterX - oldPanX) / oldScale; viewport.panX = screenCenterX - (worldPointXAtScreenCenter * newScale); const worldA4TopY = 0; viewport.panY = A4_VIEW_PADDING - (worldA4TopY * newScale); applyViewportTransform(); }
    function resetZoomTo100() {
        isA4ModeActive = true;
        viewport.scale = 1.0;
        const pageW = parseFloat(a4PageGuideRect.getAttribute('width'));
        viewport.panX = (canvasEl.clientWidth > pageW) ? (canvasEl.clientWidth / 2) - (pageW / 2) : A4_VIEW_PADDING;
        viewport.panY = A4_VIEW_PADDING;
        applyViewportTransform();
    }

    // --- Node & Element Creation ---
    function createNode(text = 'Novo Item', x = 150, y = 150, id = null, options = {}) {
        const { isUndoRedo = false, recordUndo = true, type = 'text', imageUrl = '' } = options;

        if (!isUndoRedo && x === 150 && y === 150) {
            const worldCenter = screenToWorld(canvasEl.clientWidth / 2, canvasEl.clientHeight / 2);
            x = worldCenter.x - (type === 'image' ? 75 : 50);
            y = worldCenter.y - (type === 'image' ? 75 : 20);
            const pageW = a4PageGuideRect.getAttribute('width');
            const pageH = a4PageGuideRect.getAttribute('height');
            x = Math.max(20, Math.min(x, pageW - (type === 'image' ? 150 : 120)));
            y = Math.max(20, Math.min(y, pageH - (type === 'image' ? 150 : 60)));
        }

        let nodeId = id;
        let isNewNodeFromUser = false;
        // Lógica de ID simplificada e corrigida.
        if (!nodeId) {
            isNewNodeFromUser = !isUndoRedo;
            nodeId = 'node-' + nodeCounter;
            // O contador agora só é incrementado aqui, ao criar um nó genuinamente novo.
            if (!isUndoRedo) {
                nodeCounter++;
            }
        }

        const node = document.createElement('div');
        node.className = 'node';
        node.id = nodeId;
        node.style.left = `${x}px`;
        node.style.top = `${y}px`;
        node.style.alignItems = 'center'; // Default vertical alignment

        if (type === 'image') {
            node.classList.add('node-image');
            const img = document.createElement('img');
            img.src = imageUrl;
            img.className = 'node-image-content';
            node.appendChild(img);
            node.style.width = '150px';
            node.style.height = '150px';
        } else { // type === 'text'
            const content = document.createElement('div');
            content.className = 'content';
            content.innerHTML = text;
            node.appendChild(content);
        }

        if (!id || isNewNodeFromUser) {
            node.style.backgroundColor = globalNodeBackgroundColor;
            node.style.borderColor = globalNodeBorderColor;
            node.style.borderRadius = '';
            node.style.borderWidth = `${globalNodeBorderWidth}px`;
            node.style.borderStyle = parseInt(globalNodeBorderWidth) > 0 ? 'solid' : 'none';
            if (globalNodeShape === 'ellipse') node.classList.add('node-ellipse');
        }

        ['top', 'bottom', 'left', 'right', 'center'].forEach(pos => {
            const connector = document.createElement('div');
            connector.className = 'connector ' + pos;
            connector.dataset.position = pos;
            connector.dataset.nodeId = nodeId;
            node.appendChild(connector);
        });

        container.appendChild(node);
        addNodeEventListeners(node);
        updateNodeVisuals(node);

        if (recordUndo && isNewNodeFromUser) {
            // Ao criar um novo nó, usamos o ID que acabamos de gerar.
            recordAction({ type: 'createNode', nodeData: getNodeDataForUndo(node) });
        }

        return node;
    }

    function addNodeEventListeners(node) {
        node.addEventListener('dblclick', handleNodeDblClick);
        if(node.querySelector('.content')) {
            const contentDiv = node.querySelector('.content');
            contentDiv.addEventListener('focus', () => {
                node.dataset.originalContentForUndo = contentDiv.innerHTML;
            });
            contentDiv.addEventListener('blur', handleNodeBlur);
            contentDiv.addEventListener('input', () => drawLines());
        }
    }

    // --- Styling and Formatting ---
    function showToolbar(el) {
        toolbar.style.visibility = 'visible';
        manageToolbarPositions();
    }

    function hideToolbar() {
        toolbar.style.visibility = 'hidden';
        manageToolbarPositions();
    }

    function applyFormat(cmd, val = null) {
        if (!editingNode) return;
        const contentDiv = editingNode.querySelector('.content');
        if (!contentDiv) return; // Proteção para nós de imagem

        contentDiv.focus();
        if (savedRange) {
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(savedRange);
        }

        if (cmd === 'removeFormat') {
            if (document.queryCommandState('insertUnorderedList')) {
                document.execCommand('insertUnorderedList', false, null);
            }
            document.execCommand('removeFormat', false, val);
        } else {
            document.execCommand(cmd, false, val);
        }

        contentDiv.focus();
    }

    function updateNodeVisuals(node) {
        if (!node) return;
        const isImageNode = !!node.querySelector('.node-image-content');

        // Para cor de fundo, o elemento alvo é diferente
        const bgTargetEl = isImageNode ? node.querySelector('.node-image-content') : node;
        const bgColor = bgTargetEl.style.backgroundColor;

        // Para borda e sombra, o elemento alvo é sempre o nó principal
        const borderColor = node.style.borderColor;
        const borderWidth = parseInt(node.style.borderWidth) || 0;

        const isBgTransparent = bgColor === 'transparent' || bgColor === 'rgba(0, 0, 0, 0)';
        const isBorderTransparent = borderWidth === 0 || borderColor === 'transparent' || borderColor === 'rgba(0, 0, 0, 0)';

        if (isBgTransparent && isBorderTransparent) {
            node.style.boxShadow = 'none';
        } else if (node.style.boxShadow === 'none') {
            node.style.boxShadow = '';
        }
    }

    function applyStyleToSingleNode(node, style, value) {
        if (!node || !node.classList.contains('node')) return;

        const imageContent = node.querySelector('.node-image-content');

        switch (style) {
            case 'backgroundColor':
                // Aplica ao contêiner principal para nós de texto e diretamente na imagem para nós de imagem
                const targetEl = imageContent || node;
                targetEl.style.backgroundColor = value;
                break;
            case 'borderColor':
                node.style.borderColor = value;
                break;
            case 'borderWidth':
                const width = parseInt(value, 10);
                if (isNaN(width) || width < 0) return;
                node.style.borderWidth = `${width}px`;
                node.style.borderStyle = width > 0 ? 'solid' : 'none';
                if (width > 0 && (node.style.borderColor === 'transparent' || node.style.borderColor === 'rgba(0, 0, 0, 0)')) {
                    node.style.borderColor = '#6b7280';
                }
                break;
            case 'shape':
                node.classList.remove('node-ellipse', 'node-rounded-xl', 'node-pill');
                node.style.borderRadius = '';

                if (value === 'ellipse') node.classList.add('node-ellipse');
                else if (value === 'rounded-xl') node.classList.add('node-rounded-xl');
                else if (value === 'pill') node.classList.add('node-pill');
                break;
            case 'textAlign':
                const contentDiv = node.querySelector('.content');
                if (contentDiv) contentDiv.style.textAlign = value;
                break;
            case 'alignItems': // New case for vertical alignment
                node.style.alignItems = value;
                break;
            case 'lineHeight':
                const contentDivLH = node.querySelector('.content');
                if (contentDivLH) contentDivLH.style.lineHeight = value;
                break;
        }
        updateNodeVisuals(node);
    }

    function applyNodeStyle(style, value) {
        if (!editingNode) return;
        const targets = [editingNode];
        const changes = [];
        targets.forEach(node => {
            const contentDiv = node.querySelector('.content');
            let oldValue;

            switch(style) {
                case 'backgroundColor':
                    const imageContent = node.querySelector('.node-image-content');
                    oldValue = imageContent ? imageContent.style.backgroundColor : node.style.backgroundColor;
                    break;
                case 'borderColor': oldValue = node.style.borderColor; break;
                case 'borderWidth': oldValue = node.style.borderWidth; break;
                case 'shape':
                    if (node.classList.contains('node-ellipse')) oldValue = 'ellipse';
                    else if (node.classList.contains('node-rounded-xl')) oldValue = 'rounded-xl';
                    else if (node.classList.contains('node-pill')) oldValue = 'pill';
                    else oldValue = 'rectangle';
                    break;
                case 'textAlign':
                    if (!contentDiv) return;
                    oldValue = contentDiv.style.textAlign || 'center';
                    break;
                case 'alignItems': // New case for vertical alignment
                    oldValue = node.style.alignItems || 'center';
                    break;
                case 'lineHeight':
                    if (!contentDiv) return;
                    oldValue = contentDiv.style.lineHeight || 'normal';
                    break;
                default: return;
            }
            if (oldValue !== value) {
                changes.push({ nodeId: node.id, style, oldValue, newValue: value });
                applyStyleToSingleNode(node, style, value);
            }
        });
        if (changes.length > 0) recordAction({ type: 'changeNodeStyles', changes });
        drawLines();
    }

    function toggleNodeTransparency() {
        if (!editingNode) return;
        const node = editingNode;
        const imageContent = node.querySelector('.node-image-content');
        const targetEl = imageContent || node;

        const isTransparent = targetEl.style.backgroundColor === 'transparent' || !targetEl.style.backgroundColor;

        const oldBgColor = targetEl.style.backgroundColor;
        const newBgColor = isTransparent ? (targetEl.dataset.oldBg || '#FFFFFF') : 'transparent';

        if (!isTransparent) {
            targetEl.dataset.oldBg = oldBgColor;
        }

        applyStyleToSingleNode(node, 'backgroundColor', newBgColor);
        recordAction({ type: 'changeNodeStyles', changes: [{ nodeId: node.id, style: 'backgroundColor', oldValue: oldBgColor, newValue: newBgColor }] });
    }

    function applyTextAlign(alignValue) { if (!editingNode) return; applyNodeStyle('textAlign', alignValue); }
    function applyVerticalAlign(alignValue) { if (!editingNode) return; applyNodeStyle('alignItems', alignValue); }

    function updateToolbarState(node) {
        if (!node) return;
        const styles = window.getComputedStyle(node);
        const imageContent = node.querySelector('img.node-image-content');

        if (imageContent) {
            // Atualiza os controles de imagem
            const imageStyles = window.getComputedStyle(imageContent);

            // Opacidade e Ajuste
            document.getElementById('imageOpacity').value = imageStyles.opacity || 1;
            document.getElementById('imageObjectFit').value = imageStyles.objectFit || 'contain';

            // Filtros (requer uma análise simples da string 'filter')
            const filterString = imageStyles.filter === 'none' ? '' : imageStyles.filter;
            document.getElementById('imageBrightness').value = filterString.match(/brightness\(([^)]+)\)/)?.[1] || 1;
            document.getElementById('imageContrast').value = filterString.match(/contrast\(([^)]+)\)/)?.[1] || 1;
            document.getElementById('imageSaturate').value = filterString.match(/saturate\(([^)]+)\)/)?.[1] || 1;
        }

        // Lógica comum para nós de texto e imagem (estilos do container .node)
        const borderColorHex = rgbToHex(styles.borderColor);
        toolbar.querySelector('input[data-style="borderWidth"]').value = parseInt(styles.borderWidth, 10) || 0;
        toolbar.querySelector('input[data-style="borderColor"]').value = borderColorHex;
        toolbar.querySelector('input[data-style-hex="borderColor"]').value = borderColorHex;


        const shapeSelect = toolbar.querySelector('select[data-style="shape"]');
        if (node.classList.contains('node-ellipse')) shapeSelect.value = 'ellipse';
        else if (node.classList.contains('node-rounded-xl')) shapeSelect.value = 'rounded-xl';
        else if (node.classList.contains('node-pill')) shapeSelect.value = 'pill';
        else shapeSelect.value = 'rectangle';

        // Lógica apenas para nós de texto
        const contentDiv = node.querySelector('.content');
        if (contentDiv) {
            const nodeBgColorHex = rgbToHex(window.getComputedStyle(node).backgroundColor);
            toolbar.querySelector('input[data-style="backgroundColor"]').value = nodeBgColorHex;
            toolbar.querySelector('input[data-style-hex="backgroundColor"]').value = nodeBgColorHex;

            // Atualiza cor do texto
            const selection = window.getSelection();
            let textColor = '#000000';
            if (selection.rangeCount > 0 && editingNode?.contains(selection.anchorNode)) {
                 textColor = document.queryCommandValue('foreColor');
            } else {
                 const firstTextNode = Array.from(contentDiv.querySelectorAll('*')).find(el => el.style?.color) || contentDiv;
                 textColor = window.getComputedStyle(firstTextNode).color;
            }
            const textColorHex = rgbToHex(textColor);
            document.getElementById('customColor').value = textColorHex;
            document.getElementById('customColorHex').value = textColorHex;


            const contentStyles = window.getComputedStyle(contentDiv);
            const lineHeightSelect = toolbar.querySelector('select[data-style="lineHeight"]');
            const currentLineHeight = contentStyles.lineHeight;

            if (currentLineHeight === 'normal') {
                lineHeightSelect.value = 'normal';
            } else {
                const pixelValue = parseFloat(currentLineHeight);
                const fontSize = parseFloat(contentStyles.fontSize);
                // Previne divisão por zero se o tamanho da fonte for 0
                const ratio = fontSize > 0 ? (pixelValue / fontSize).toFixed(1) : 0;
                let bestMatch = 'normal';

                // Lógica atualizada para encontrar a melhor correspondência, incluindo "Compacto"
                if (ratio <= 0.9) {
                    bestMatch = '0.8'; // Compacto
                } else if (ratio <= 1.2) {
                    bestMatch = '1';   // Simples
                } else if (ratio <= 1.6) {
                    bestMatch = '1.5'; // 1.5
                } else {
                    bestMatch = '2';   // Duplo
                }
                lineHeightSelect.value = bestMatch;
            }
        }
    }

    // --- Funções de Manipulação de Imagem ---
    function applyImageStyles() {
        if (!editingNode) return;
        const imageEl = editingNode.querySelector('img.node-image-content');
        if (!imageEl) return;

        imageEl.style.objectFit = document.getElementById('imageObjectFit').value;
        imageEl.style.opacity = document.getElementById('imageOpacity').value;

        const brightness = document.getElementById('imageBrightness').value;
        const contrast = document.getElementById('imageContrast').value;
        const saturate = document.getElementById('imageSaturate').value;

        imageEl.style.filter = `brightness(${brightness}) contrast(${contrast}) saturate(${saturate})`;
    }

    function resetImageStyles() {
        if (!editingNode) return;
        const imageEl = editingNode.querySelector('img.node-image-content');
        if (!imageEl) return;

        imageEl.style.filter = '';
        imageEl.style.opacity = '';
        imageEl.style.objectFit = 'contain';

        document.getElementById('imageObjectFit').value = 'contain';
        document.getElementById('imageOpacity').value = 1;
        document.getElementById('imageBrightness').value = 1;
        document.getElementById('imageContrast').value = 1;
        document.getElementById('imageSaturate').value = 1;
    }

    // --- Line Drawing & Connections ---
    function getConnectorPosition(el, pos) {
        const absPos = getAbsolutePosition(el);
        const nodeWorldWidth = el.offsetWidth, nodeWorldHeight = el.offsetHeight;
        switch (pos) {
            case 'top':    return { x: absPos.x + nodeWorldWidth / 2, y: absPos.y };
            case 'bottom': return { x: absPos.x + nodeWorldWidth / 2, y: absPos.y + nodeWorldHeight };
            case 'left':   return { x: absPos.x, y: absPos.y + nodeWorldHeight / 2 };
            case 'right':  return { x: absPos.x + nodeWorldWidth, y: absPos.y + nodeWorldHeight / 2 };
            case 'center': return { x: absPos.x + nodeWorldWidth / 2, y: absPos.y + nodeWorldHeight / 2 };
            default:       return { x: absPos.x + nodeWorldWidth / 2, y: absPos.y + nodeWorldHeight / 2 };
        }
    }
    function createSvgPath(d, isTemp = false) { const p = document.createElementNS('http://www.w3.org/2000/svg', 'path'); p.setAttribute('d', d); p.style.fill = 'none'; p.style.strokeLinecap = 'round'; p.style.strokeLinejoin = 'round'; p.style.vectorEffect = "non-scaling-stroke"; if (isTemp) { p.classList.add('temp'); p.style.stroke = themeColors.connection; p.style.strokeWidth = String(currentLineStrokeWidth); p.style.strokeDasharray = '6, 4'; } else { p.style.stroke = currentLineColor; p.style.strokeWidth = String(currentLineStrokeWidth); } svg.appendChild(p); }
    function drawLines() {
        svg.innerHTML = '';
        connections.forEach((conn, index) => {
            const fromNode = document.getElementById(conn.from);
            const toNode = document.getElementById(conn.to);
            if (!fromNode || !toNode) return;
            const start = getConnectorPosition(fromNode, conn.fromPos);
            const end = getConnectorPosition(toNode, conn.toPos);
            const dx = end.x - start.x, dy = end.y - start.y;
            const factor = 0.6;
            let c1x, c1y, c2x, c2y;
            if (['left', 'right'].includes(conn.fromPos)) { c1x = start.x + dx * factor; c1y = start.y; } else { c1x = start.x; c1y = start.y + dy * factor; }
            if (['left', 'right'].includes(conn.toPos)) { c2x = end.x - dx * factor; c2y = end.y; } else { c2x = end.x; c2y = end.y - dy * factor; }
            const pathData = `M${start.x},${start.y} C${c1x},${c1y} ${c2x},${c2y} ${end.x},${end.y}`;
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.classList.add('connection-group');
            group.dataset.connIndex = String(index);
            const isSelected = selectedConnections.has(index);
            const visibleLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            visibleLine.setAttribute('d', pathData);
            visibleLine.style.fill = 'none';
            visibleLine.style.strokeLinecap = 'round';
            visibleLine.style.strokeLinejoin = 'round';
            visibleLine.style.pointerEvents = 'none';
            visibleLine.style.vectorEffect = "non-scaling-stroke";
            visibleLine.style.stroke = isSelected ? themeColors.connectionSelected : (conn.color || currentLineColor);
            visibleLine.style.strokeWidth = isSelected ? String(Number(conn.width || currentLineStrokeWidth) + 1.5) : String(conn.width || currentLineStrokeWidth);
            const hitBoxLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            hitBoxLine.setAttribute('d', pathData);
            hitBoxLine.style.stroke = 'transparent';
            hitBoxLine.style.strokeWidth = '15px';
            hitBoxLine.style.fill = 'none';
            hitBoxLine.style.cursor = 'pointer';
            group.appendChild(hitBoxLine);
            group.appendChild(visibleLine);
            svg.appendChild(group);
        });

        if (actionState.type === 'linking' && actionState.target) {
            const start = getConnectorPosition(actionState.target, actionState.linkStartPos);
            let endPoint = screenToWorld(globalScreenMouse.x, globalScreenMouse.y);

            const snappedEl = document.querySelector('.connector.snap-target');
            if (snappedEl) {
                const nodeEl = document.getElementById(snappedEl.dataset.nodeId);
                if (nodeEl) {
                    endPoint = getConnectorPosition(nodeEl, snappedEl.dataset.position);
                }
            }

            const dx = endPoint.x - start.x, dy = endPoint.y - start.y;
            const factor = 0.6;
            let c1x, c1y, c2x, c2y;
            if (['left', 'right'].includes(actionState.linkStartPos)) { c1x = start.x + dx * factor; c1y = start.y; } else { c1x = start.x; c1y = start.y + dy * factor; }
            c2x = endPoint.x - dx * (1 - factor); c2y = endPoint.y - dy * (1 - factor);
            createSvgPath(`M${start.x},${start.y} C${c1x},${c1y} ${c2x},${c2y} ${endPoint.x},${endPoint.y}`, true);
        }
    }

    // --- Grouping Logic ---
    function getAbsolutePosition(element) {
        let x = 0, y = 0;
        let currentElement = element;
        while (currentElement && currentElement !== container) {
            x += currentElement.offsetLeft;
            y += currentElement.offsetTop;
            currentElement = currentElement.offsetParent;
        }
        return { x, y };
    }

    function handleGroup() {
        const itemsToGroup = Array.from(selectedItems).map(id => document.getElementById(id)).filter(el => el && (el.classList.contains('node') || el.classList.contains('group-container')));
        if (itemsToGroup.length < 2) {
            showModal("Por favor, selecione pelo menos dois itens para agrupar.");
            return;
        }

        const oldItemsData = itemsToGroup.map(item => {
            const absPos = getAbsolutePosition(item);
            return { id: item.id, left: absPos.x + 'px', top: absPos.y + 'px' };
        });

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        itemsToGroup.forEach(item => {
            const absPos = getAbsolutePosition(item);
            minX = Math.min(minX, absPos.x);
            minY = Math.min(minY, absPos.y);
            maxX = Math.max(maxX, absPos.x + item.offsetWidth);
            maxY = Math.max(maxY, absPos.y + item.offsetHeight);
        });

        const padding = 25;
        const groupLeft = minX - padding;
        const groupTop = minY - padding;
        const groupWidth = (maxX - minX) + (2 * padding);
        const groupHeight = (maxY - minY) + (2 * padding);

        const groupContainer = document.createElement('div');
        const groupId = 'group-' + Date.now();
        groupContainer.id = groupId;
        groupContainer.className = 'group-container';
        groupContainer.style.left = `${groupLeft}px`;
        groupContainer.style.top = `${groupTop}px`;
        groupContainer.style.width = `${groupWidth}px`;
        groupContainer.style.height = `${groupHeight}px`;
        container.appendChild(groupContainer);

        itemsToGroup.forEach(item => {
            const absPos = getAbsolutePosition(item);
            item.style.left = `${absPos.x - groupLeft}px`;
            item.style.top = `${absPos.y - groupTop}px`;
            if (item.classList.contains('node')) item.classList.add('in-group');
            groupContainer.appendChild(item);
        });

        recordAction({
            type: 'group',
            groupId: groupId,
            groupedItemsData: oldItemsData,
            groupRect: { left: groupContainer.style.left, top: groupContainer.style.top, width: groupContainer.style.width, height: groupContainer.style.height }
        });

        selectedItems.clear();
        selectedItems.add(groupContainer.id);
        updateSelectionVisuals();
        drawLines();
    }

    function handleUngroup() {
        const groupsToUngroup = Array.from(selectedItems).map(id => document.getElementById(id)).filter(el => el && el.classList.contains('group-container'));
        if (groupsToUngroup.length === 0) {
            showModal("Por favor, selecione um grupo para desagrupar.");
            return;
        }

        const ungroupedData = [];
        const newlySelectedIds = new Set();

        groupsToUngroup.forEach(groupContainer => {
            const groupAbsPos = getAbsolutePosition(groupContainer);
            const childItems = Array.from(groupContainer.children).filter(c => c.classList.contains('node') || c.classList.contains('group-container'));

            ungroupedData.push({
                groupData: { id: groupContainer.id, left: groupContainer.style.left, top: groupContainer.style.top, width: groupContainer.style.width, height: groupContainer.style.height },
                childrenData: childItems.map(child => ({ id: child.id, left: child.style.left, top: child.style.top }))
            });

            childItems.forEach(child => {
                const childNewLeft = groupAbsPos.x + child.offsetLeft;
                const childNewTop = groupAbsPos.y + child.offsetTop;
                child.style.left = `${childNewLeft}px`;
                child.style.top = `${childNewTop}px`;
                if(child.classList.contains('node')) child.classList.remove('in-group');
                container.appendChild(child);
                newlySelectedIds.add(child.id);
            });
            groupContainer.remove();
        });

        recordAction({ type: 'ungroup', ungroupedData });

        selectedItems.clear();
        newlySelectedIds.forEach(id => selectedItems.add(id));
        updateSelectionVisuals();
        drawLines();
    }

    // --- Lógica do Painel Flutuante ---
    function manageToolbarPositions() {
        const canvasRect = canvasEl.getBoundingClientRect();
        const allItems = document.querySelectorAll('.node, .group-container');
        const spacing = 10;
        const toolbarWidth = 280;

        const visibleToolbars = [toolbar, multiSelectToolbar, connectionToolbar, groupContextMenu]
            .filter(tb => {
                const style = window.getComputedStyle(tb);
                return style.visibility !== 'hidden' && style.display !== 'none';
            });

        if (visibleToolbars.length === 0) return;

        const totalHeight = visibleToolbars.reduce((sum, tb) => sum + tb.offsetHeight, 0) + Math.max(0, visibleToolbars.length - 1) * spacing;

        const potentialPositions = [
            { left: canvasRect.left + 20, top: canvasRect.top + 80 },
            { left: canvasRect.right - toolbarWidth - 20, top: canvasRect.top + 80 }
        ];

        let chosenPosition = null;

        for (const pos of potentialPositions) {
            let hasOverlap = false;
            const stackRect = {
                left: pos.left,
                top: pos.top,
                right: pos.left + toolbarWidth,
                bottom: pos.top + totalHeight
            };

            for (const item of allItems) {
                const itemRect = item.getBoundingClientRect();
                if (itemRect.width === 0 && itemRect.height === 0) continue;

                if (!(stackRect.right < itemRect.left || stackRect.left > itemRect.right || stackRect.bottom < itemRect.top || stackRect.top > itemRect.bottom)) {
                    hasOverlap = true;
                    break;
                }
            }

            if (!hasOverlap) {
                chosenPosition = pos;
                break;
            }
        }

        if (!chosenPosition) {
            chosenPosition = potentialPositions[0];
        }

        let currentTop = chosenPosition.top;
        visibleToolbars.forEach(tb => {
            tb.style.left = `${chosenPosition.left}px`;
            tb.style.top = `${currentTop}px`;
            currentTop += tb.offsetHeight + spacing;
        });
    }

    function showMultiSelectToolbar() {
        if (selectedItems.size <= 1) {
            hideMultiSelectToolbar();
            return;
        }

        let hasVisibleItems = false;
        selectedItems.forEach(id => {
            const item = document.getElementById(id);
            if (item) {
                hasVisibleItems = true;
            }
        });

        if (!hasVisibleItems) {
            hideMultiSelectToolbar();
            return;
        }

        multiSelectToolbar.style.visibility = 'visible';
        manageToolbarPositions();
    }

    function hideMultiSelectToolbar() {
        multiSelectToolbar.style.visibility = 'hidden';
        manageToolbarPositions();
    }

    // --- Lógica do Painel de Conexão ---
    function showConnectionToolbar() {
        if (selectedConnections.size === 0) {
            hideConnectionToolbar();
            return;
        }
        const firstConnIndex = selectedConnections.values().next().value;
        const firstConn = connections[firstConnIndex];
        if (firstConn) {
            connectionToolbar.querySelector('[data-conn-style="color"]').value = firstConn.color || currentLineColor;
            connectionToolbar.querySelector('[data-conn-style="width"]').value = firstConn.width || currentLineStrokeWidth;
        }

        connectionToolbar.style.visibility = 'visible';
        manageToolbarPositions();
    }

    function hideConnectionToolbar() {
        connectionToolbar.style.visibility = 'hidden';
        manageToolbarPositions();
    }

    function applyBulkStyles() {
        const newBgColor = multiSelectToolbar.querySelector('[data-multi-style="backgroundColor"]').value;
        const newBorderColor = multiSelectToolbar.querySelector('[data-multi-style="borderColor"]').value;
        const newBorderWidth = multiSelectToolbar.querySelector('[data-multi-style="borderWidth"]').value;
        const newShape = multiSelectToolbar.querySelector('[data-multi-style="shape"]').value;

        const changes = [];
        const nodesToChange = Array.from(selectedItems)
            .map(id => document.getElementById(id))
            .filter(el => el && el.classList.contains('node'));

        if (nodesToChange.length === 0) return;

        nodesToChange.forEach(node => {
            let oldShape = 'rectangle';
            if (node.classList.contains('node-ellipse')) oldShape = 'ellipse';
            else if (node.classList.contains('node-rounded-xl')) oldShape = 'rounded-xl';
            else if (node.classList.contains('node-pill')) oldShape = 'pill';

            changes.push({
                nodeId: node.id,
                oldStyles: {
                    backgroundColor: node.style.backgroundColor,
                    borderColor: node.style.borderColor,
                    borderWidth: node.style.borderWidth,
                    shape: oldShape
                }
            });

            applyStyleToSingleNode(node, 'backgroundColor', newBgColor);
            applyStyleToSingleNode(node, 'borderColor', newBorderColor);
            applyStyleToSingleNode(node, 'borderWidth', newBorderWidth);
            applyStyleToSingleNode(node, 'shape', newShape);
        });

        if (changes.length > 0) {
            recordAction({
                type: 'bulkChangeNodeStyles',
                changes: changes,
                newStyles: {
                    backgroundColor: newBgColor,
                    borderColor: newBorderColor,
                    borderWidth: newBorderWidth,
                    shape: newShape
                }
            });
        }
        drawLines();
    }

    function applyConnectionStyles() {
        if (selectedConnections.size === 0) return;
        const newColor = connectionToolbar.querySelector('[data-conn-style="color"]').value;
        const newWidth = connectionToolbar.querySelector('[data-conn-style="width"]').value;

        const changes = [];
        selectedConnections.forEach(index => {
            const conn = connections[index];
            if(conn) {
                const oldStyles = { color: conn.color || currentLineColor, width: conn.width || currentLineStrokeWidth };
                if (oldStyles.color !== newColor || String(oldStyles.width) !== newWidth) {
                     changes.push({ index: index, oldStyles: oldStyles });
                     conn.color = newColor;
                     conn.width = parseFloat(newWidth);
                }
            }
        });

        if (changes.length > 0) {
             recordAction({
                type: 'changeConnectionStyles',
                changes: changes,
                newStyles: { color: newColor, width: parseFloat(newWidth) }
            });
        }
        drawLines();
    }

    function updateMultiSelectToolbarState() {
        const selectionSize = selectedItems.size;
        const hasGroup = [...selectedItems].some(id => document.getElementById(id)?.classList.contains('group-container'));

        const canAlign = selectionSize >= 2;
        const canGroup = selectionSize >= 2;
        const canUngroup = hasGroup;

        multiSelectToolbar.querySelectorAll('[data-action="group"]').forEach(btn => btn.disabled = !canGroup);
        multiSelectToolbar.querySelectorAll('[data-action="ungroup"]').forEach(btn => btn.disabled = !canUngroup);
        multiSelectToolbar.querySelectorAll('[data-align], [data-distribute]').forEach(btn => btn.disabled = !canAlign);
    }

    // --- Selection & Alignment ---
    // NOVO: Função para desenhar as guias de alinhamento
    function updateAndDrawAlignmentGuides(movingRect, movingItemIds, direction, delta) {
    alignmentGuidesSvg.innerHTML = '';
    if (!movingRect) return { x: 0, y: 0 };

    // Define os pontos do retângulo em movimento que vamos testar para alinhamento
    const movingRectPoints = {
        left: movingRect.left,
        midX: movingRect.left + movingRect.width / 2,
        right: movingRect.left + movingRect.width,
        top: movingRect.top,
        midY: movingRect.top + movingRect.height / 2,
        bottom: movingRect.top + movingRect.height,
    };

    let activePointsX = [], activePointsY = [];

    // Se estiver arrastando, todos os pontos são ativos
    if (direction === 'move') {
        activePointsX = [{ pos: movingRectPoints.left, type: 'left' }, { pos: movingRectPoints.midX, type: 'midX' }, { pos: movingRectPoints.right, type: 'right' }];
        activePointsY = [{ pos: movingRectPoints.top, type: 'top' }, { pos: movingRectPoints.midY, type: 'midY' }, { pos: movingRectPoints.bottom, type: 'bottom' }];
    } else { // Se estiver redimensionando, apenas os pontos relevantes para a direção são ativos
        if (direction.includes('l')) activePointsX.push({ pos: movingRectPoints.left, type: 'left' });
        if (direction.includes('r')) activePointsX.push({ pos: movingRectPoints.right, type: 'right' });
        if (direction.includes('t')) activePointsY.push({ pos: movingRectPoints.top, type: 'top' });
        if (direction.includes('b')) activePointsY.push({ pos: movingRectPoints.bottom, type: 'bottom' });
        // Adiciona centros se não houver um lado específico (ex: 'tm', 'ml')
        if (direction.includes('m') && !direction.includes('l') && !direction.includes('r')) activePointsX.push({ pos: movingRectPoints.midX, type: 'midX' });
        if (direction.includes('m') && !direction.includes('t') && !direction.includes('b')) activePointsY.push({ pos: movingRectPoints.midY, type: 'midY' });
    }

    const allNodes = Array.from(document.querySelectorAll('.node:not(.in-group), .group-container'));
    let candidateSnapsX = [], candidateSnapsY = [];

    allNodes.forEach(otherNode => {
        if (movingItemIds.has(otherNode.id)) return;

        // Pontos de "snap" do outro nó (os alvos)
        const oWorldRect = { left: otherNode.offsetLeft, top: otherNode.offsetTop, width: otherNode.offsetWidth, height: otherNode.offsetHeight };
        const oPointsX = [oWorldRect.left, oWorldRect.left + oWorldRect.width / 2, oWorldRect.left + oWorldRect.width];
        const oPointsY = [oWorldRect.top, oWorldRect.top + oWorldRect.height / 2, oWorldRect.top + oWorldRect.height];

        // Compara pontos ativos (do nó em movimento) com pontos alvo (dos outros nós)
        activePointsX.forEach(activePt => {
            oPointsX.forEach(targetPt => {
                const distance = Math.abs(activePt.pos - targetPt);
                if (distance < (SNAP_THRESHOLD / viewport.scale)) {
                    if ((delta.x < 0 && targetPt <= activePt.pos) || (delta.x > 0 && targetPt >= activePt.pos) || delta.x === 0) {
                        candidateSnapsX.push({ distance, adjustment: targetPt - activePt.pos, guidePos: targetPt });
                    }
                }
            });
        });
        activePointsY.forEach(activePt => {
            oPointsY.forEach(targetPt => {
                const distance = Math.abs(activePt.pos - targetPt);
                if (distance < (SNAP_THRESHOLD / viewport.scale)) {
                     if ((delta.y < 0 && targetPt <= activePt.pos) || (delta.y > 0 && targetPt >= activePt.pos) || delta.y === 0) {
                        candidateSnapsY.push({ distance, adjustment: targetPt - activePt.pos, guidePos: targetPt });
                    }
                }
            });
        });
    });

    let finalAdjustment = { x: 0, y: 0 };
    const canvasRect = canvasEl.getBoundingClientRect();
    const worldView = {
        top: screenToWorld(canvasRect.left, canvasRect.top).y, bottom: screenToWorld(canvasRect.left, canvasRect.bottom).y,
        left: screenToWorld(canvasRect.left, canvasRect.top).x, right: screenToWorld(canvasRect.right, canvasRect.top).x
    };

    if (candidateSnapsX.length > 0) {
        candidateSnapsX.sort((a, b) => a.distance - b.distance);
        const bestSnapX = candidateSnapsX[0];
        finalAdjustment.x = bestSnapX.adjustment;

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('class', 'alignment-guide');
        line.setAttribute('x1', bestSnapX.guidePos); line.setAttribute('x2', bestSnapX.guidePos);
        line.setAttribute('y1', worldView.top); line.setAttribute('y2', worldView.bottom);
        alignmentGuidesSvg.appendChild(line);
    }

    if (candidateSnapsY.length > 0) {
        candidateSnapsY.sort((a, b) => a.distance - b.distance);
        const bestSnapY = candidateSnapsY[0];
        finalAdjustment.y = bestSnapY.adjustment;

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('class', 'alignment-guide');
        line.setAttribute('y1', bestSnapY.guidePos); line.setAttribute('y2', bestSnapY.guidePos);
        line.setAttribute('x1', worldView.left); line.setAttribute('x2', worldView.right);
        alignmentGuidesSvg.appendChild(line);
    }

    return finalAdjustment;
}

    // ATUALIZADO: Função para gerenciar o estado visual da seleção
    function updateSelectionVisuals() {
        // Remove todas as classes de seleção e alças de redimensionamento existentes
        document.querySelectorAll('.node.selected, .group-container.selected').forEach(el => el.classList.remove('selected'));
        document.querySelectorAll('.resize-handles-container').forEach(container => container.remove());

        // Adiciona a classe 'selected' aos itens atualmente selecionados
        selectedItems.forEach(id => {
            const item = document.getElementById(id);
            if (item) item.classList.add('selected');
        });

        // Gerencia a visibilidade das barras de ferramentas
        if (selectedItems.size > 1) {
            showMultiSelectToolbar();
            updateMultiSelectToolbarState();
        } else {
            hideMultiSelectToolbar();
        }

        if (selectedConnections.size > 0) {
            showConnectionToolbar();
        } else {
            hideConnectionToolbar();
        }

        // --- LÓGICA PRINCIPAL: ADICIONA AS ALÇAS DE REDIMENSIONAMENTO ---
        // Se houver exatamente um item selecionado, e for um nó...
        if (selectedItems.size === 1) {
            const selectedId = selectedItems.values().next().value;
            const node = document.getElementById(selectedId);

            // Verifica se o item selecionado é um nó (e não um grupo)
            if (node && node.classList.contains('node')) {
                // Cria o container para as 8 alças
                const handlesContainer = document.createElement('div');
                handlesContainer.className = 'resize-handles-container';

                // Define as 8 posições/direções das alças
                const handleDirections = ['tl', 'tm', 'tr', 'ml', 'mr', 'bl', 'bm', 'br'];

                // Cria cada alça e a adiciona ao container
                handleDirections.forEach(dir => {
                    const handle = document.createElement('div');
                    handle.className = `resize-handle ${dir}`;
                    handle.dataset.direction = dir; // Armazena a direção para a lógica de redimensionamento
                    handlesContainer.appendChild(handle);
                });

                // Anexa o container de alças diretamente ao nó selecionado
                node.appendChild(handlesContainer);
            }
        }
    }

    function selectItem(item, isCtrlPressed) {
        const itemId = item.id;
        if (!isCtrlPressed && selectedItems.has(itemId) && selectedItems.size === 1) return;
        if (!isCtrlPressed) selectedItems.clear();
        if (selectedItems.has(itemId)) selectedItems.delete(itemId); else selectedItems.add(itemId);
        updateSelectionVisuals();
    }
    function selectNodesInRect(rect, isCtrlPressed) {
        if (!isCtrlPressed) {
            selectedItems.clear();
            selectedConnections.clear();
        }

        // Select nodes and groups
        document.querySelectorAll('.node:not(.in-group), .group-container').forEach(item => {
            const itemRect = item.getBoundingClientRect();
            if (!(rect.right < itemRect.left || rect.left > itemRect.right || rect.bottom < itemRect.top || rect.top > itemRect.bottom)) {
                 selectedItems.add(item.id);
            }
        });

        // Select connections
        document.querySelectorAll('g.connection-group').forEach(group => {
            const connIndex = parseInt(group.dataset.connIndex, 10);
            const lineRect = group.getBoundingClientRect();

            // Check for intersection
            const intersects = !(
                rect.right < lineRect.left ||
                rect.left > lineRect.right ||
                rect.bottom < lineRect.top ||
                rect.top > lineRect.bottom
            );

            if (intersects) {
                if (isFinite(connIndex)) {
                     selectedConnections.add(connIndex);
                }
            }
        });

        updateSelectionVisuals();
        drawLines(); // Redraw lines to show selection highlights
    }
    function clearSelection() { const hadNodeSelection = selectedItems.size > 0; const hadConnSelection = selectedConnections.size > 0; selectedItems.clear(); selectedConnections.clear(); if (hadNodeSelection) updateSelectionVisuals(); if (hadConnSelection) { drawLines(); updateSelectionVisuals(); } hideMultiSelectToolbar(); hideConnectionToolbar(); }
    function handleDelete() {
        if (selectedConnections.size > 0) {
            const connectionsToDelete = Array.from(selectedConnections).map(index => connections[index]).filter(Boolean);
            if (connectionsToDelete.length > 0) {
                recordAction({ type: 'deleteConnections', deletedConns: connectionsToDelete });
                const connectionsToDeleteSet = new Set(connectionsToDelete.map(c => JSON.stringify(c)));
                connections = connections.filter(c => !connectionsToDeleteSet.has(JSON.stringify(c)));
            }
            selectedConnections.clear();
            drawLines();
            updateSelectionVisuals();
        } else if (selectedItems.size > 0) {
            const nodesToDeleteData = [];
            const connectionsLinkedToDeletedNodes = [];
            const itemsToDelete = Array.from(selectedItems).map(id => document.getElementById(id)).filter(Boolean);
            const nodeIdsToDelete = new Set();
            itemsToDelete.forEach(item => {
                if (item.classList.contains('group-container')) { item.querySelectorAll('.node').forEach(node => nodeIdsToDelete.add(node.id)); }
                else if (item.classList.contains('node')) { nodeIdsToDelete.add(item.id); }
            });
            nodeIdsToDelete.forEach(nodeId => {
                const node = document.getElementById(nodeId);
                if (node) {
                    nodesToDeleteData.push(getNodeDataForUndo(node));
                    connections.forEach(conn => {
                        if (conn.from === nodeId || conn.to === nodeId) {
                            if (!connectionsLinkedToDeletedNodes.some(c => c.from === conn.from && c.to === c.to)) {
                                connectionsLinkedToDeletedNodes.push({ ...conn });
                            }
                        }
                    });
                }
            });
            if (nodesToDeleteData.length > 0) recordAction({ type: 'deleteNodes', nodesData: nodesToDeleteData, connectionsData: connectionsLinkedToDeletedNodes });
            itemsToDelete.forEach(item => item.remove());
            connections = connections.filter(c => !nodeIdsToDelete.has(c.from) && !nodeIdsToDelete.has(c.to));
            selectedItems.clear();
            updateSelectionVisuals();
            drawLines();
        }
    }

    // --- Page Settings Logic ---
    function updatePageGuide() {
        const size = pageSizeSelect.value;
        const orientation = pageOrientationSelect.value;
        let finalWidth, finalHeight;
        if (size === 'custom') {
            finalWidth = parseInt(pageCustomWidth.value, 10);
            finalHeight = parseInt(pageCustomHeight.value, 10);
        } else {
            const dims = PAGE_SIZES_PX[size];
            if (orientation === 'landscape') { finalWidth = dims.height; finalHeight = dims.width; }
            else { finalWidth = dims.width; finalHeight = dims.height; }
        }
        if (a4PageGuideRect) { a4PageGuideRect.setAttribute('width', finalWidth); a4PageGuideRect.setAttribute('height', finalHeight); }
    }

    function alignSelected(type) { const nodes = Array.from(selectedItems).map(id => document.getElementById(id)).filter(Boolean); if (nodes.length < 2) return; const initialPositions = nodes.map(node => ({ nodeId: node.id, oldLeft: `${node.offsetLeft}px`, oldTop: `${node.offsetTop}px` })); let targetPos; switch (type) { case 'left': targetPos = Math.min(...nodes.map(n => n.offsetLeft)); nodes.forEach(n => n.style.left = `${targetPos}px`); break; case 'right': targetPos = Math.max(...nodes.map(n => n.offsetLeft + n.offsetWidth)); nodes.forEach(n => n.style.left = `${Math.round(targetPos - n.offsetWidth)}px`); break; case 'top': targetPos = Math.min(...nodes.map(n => n.offsetTop)); nodes.forEach(n => n.style.top = `${targetPos}px`); break; case 'bottom': targetPos = Math.max(...nodes.map(n => n.offsetTop + n.offsetHeight)); nodes.forEach(n => n.style.top = `${Math.round(targetPos - n.offsetHeight)}px`); break; case 'center-h': const midX = nodes.reduce((sum, n) => sum + n.offsetLeft + n.offsetWidth / 2, 0) / nodes.length; nodes.forEach(n => n.style.left = `${Math.round(midX - n.offsetWidth / 2)}px`); break; case 'center-v': const midY = nodes.reduce((sum, n) => sum + n.offsetTop + n.offsetHeight / 2, 0) / nodes.length; nodes.forEach(n => n.style.top = `${Math.round(midY - n.offsetHeight / 2)}px`); break; } const finalChanges = initialPositions.map(pos => ({ ...pos, newLeft: document.getElementById(pos.nodeId).style.left, newTop: document.getElementById(pos.nodeId).style.top })).filter(c => c.oldLeft !== c.newLeft || c.oldTop !== c.newTop); if (finalChanges.length > 0) recordAction({ type: 'moveNodes', changes: finalChanges }); drawLines(); }
    function distributeSelected(type) { const nodes = Array.from(selectedItems).map(id => document.getElementById(id)).filter(Boolean); if (nodes.length < 2) return; const initialPositions = nodes.map(node => ({ nodeId: node.id, oldLeft: `${node.offsetLeft}px`, oldTop: `${node.offsetTop}px` })); if (type === 'horizontal') { nodes.sort((a, b) => a.offsetLeft - b.offsetLeft); const minLeft = nodes[0].offsetLeft; const maxRight = nodes[nodes.length - 1].offsetLeft + nodes[nodes.length - 1].offsetWidth; const totalSpan = maxRight - minLeft; let totalNodesWidth = nodes.reduce((sum, n) => sum + n.offsetWidth, 0); const gap = (totalSpan - totalNodesWidth) / (nodes.length - 1); let currentX = parseFloat(minLeft); for (let i = 0; i < nodes.length; i++) { nodes[i].style.left = `${Math.round(currentX)}px`; currentX += nodes[i].offsetWidth + gap; } } else if (type === 'vertical') { nodes.sort((a, b) => a.offsetTop - b.offsetTop); const minTop = nodes[0].offsetTop; const maxBottom = nodes[nodes.length - 1].offsetTop + nodes[nodes.length - 1].offsetHeight; const totalSpan = maxBottom - minTop; let totalNodesHeight = nodes.reduce((sum, n) => sum + n.offsetHeight, 0); const gap = (totalSpan - totalNodesHeight) / (nodes.length - 1); let currentY = parseFloat(minTop); for (let i = 0; i < nodes.length; i++) { nodes[i].style.top = `${Math.round(currentY)}px`; currentY += nodes[i].offsetHeight + gap; } } const finalChanges = initialPositions.map(pos => ({ ...pos, newLeft: document.getElementById(pos.nodeId).style.left, newTop: document.getElementById(pos.nodeId).style.top })).filter(c => c.oldLeft !== c.newLeft || c.oldTop !== c.newTop); if (finalChanges.length > 0) recordAction({ type: 'moveNodes', changes: finalChanges }); drawLines(); }

    // --- Clipboard & Save/Load ---
    function handleCopy() {
        const nodesToProcess = Array.from(selectedItems)
            .map(id => document.getElementById(id))
            .filter(el => el?.classList.contains('node'));

        if (nodesToProcess.length === 0) {
            // Limpa o clipboard se nada for selecionado
            appClipboard = { type: null, items: [], connections: [], anchor: { left: 0, top: 0 } };
            return;
        }

        const selectedNodeIds = new Set(nodesToProcess.map(n => n.id));
        let minLeft = Math.min(...nodesToProcess.map(n => n.offsetLeft));
        let minTop = Math.min(...nodesToProcess.map(n => n.offsetTop));

        // Copia os dados dos nós, incluindo seus IDs originais
        const copiedItems = nodesToProcess.map(node => {
            const imageEl = node.querySelector('img.node-image-content');
            const baseData = {
                originalId: node.id, // Adicionado: guarda o ID original para recriar as conexões
                width: node.offsetWidth,
                height: node.offsetHeight,
                relativeLeft: node.offsetLeft - minLeft,
                relativeTop: node.offsetTop - minTop,
                className: node.className,
                inlineStyle: node.style.cssText
            };
            if (imageEl) {
                return { ...baseData, type: 'image', imageUrl: imageEl.src, imageStyle: imageEl.style.cssText };
            }
            const contentDiv = node.querySelector('.content');
            return { ...baseData, type: 'text', contentHTML: contentDiv.innerHTML, contentTextAlign: contentDiv.style.textAlign, contentLineHeight: contentDiv.style.lineHeight, alignItems: node.style.alignItems };
        });

        // Adicionado: Filtra e copia as conexões que estão inteiramente dentro da seleção
        const copiedConnections = connections.filter(conn =>
            selectedNodeIds.has(conn.from) && selectedNodeIds.has(conn.to)
        );

        // Atualiza a estrutura do clipboard global
        appClipboard = {
            type: 'copy',
            items: copiedItems,
            connections: copiedConnections,
            anchor: { left: minLeft, top: minTop }
        };
    }


    function handleCut() { handleCopy(); if (appClipboard.items.length > 0) { appClipboard.type = 'cut'; handleDelete(); } }
    function handlePaste() {
        if (!appClipboard.items || appClipboard.items.length === 0) return;

        const canvasRect = canvasEl.getBoundingClientRect();
        const isMouseOutside = globalScreenMouse.x < canvasRect.left || globalScreenMouse.x > canvasRect.right || globalScreenMouse.y < canvasRect.top || globalScreenMouse.y > canvasRect.bottom || (globalScreenMouse.x === 0 && globalScreenMouse.y === 0);
        const worldMousePaste = screenToWorld(globalScreenMouse.x, globalScreenMouse.y);
        const basePastePos = isMouseOutside ? { x: appClipboard.anchor.left + 20, y: appClipboard.anchor.top + 20 } : { x: worldMousePaste.x, y: worldMousePaste.y };

        clearSelection();

        const idMap = new Map();
        const pastedNodesData = [];

        // 1. Criar os novos nós e mapear os IDs antigos para os novos
        appClipboard.items.forEach(itemData => {
            const newPos = { x: basePastePos.x + itemData.relativeLeft, y: basePastePos.y + itemData.relativeTop };
            const newNode = createNode(itemData.type === 'text' ? itemData.contentHTML : null, newPos.x, newPos.y, null, { recordUndo: false, type: itemData.type, imageUrl: itemData.imageUrl });

            Object.assign(newNode.style, { cssText: itemData.inlineStyle, width: `${itemData.width}px`, height: `${itemData.height}px`, left: `${newPos.x}px`, top: `${newPos.y}px` });
            newNode.className = itemData.className;
            if (itemData.type === 'image' && itemData.imageStyle) newNode.querySelector('img.node-image-content').style.cssText = itemData.imageStyle;
            if (itemData.type === 'text') Object.assign(newNode.querySelector('.content').style, { textAlign: itemData.contentTextAlign || '', lineHeight: itemData.contentLineHeight || '' });

            newNode.classList.remove('selected', 'editing', 'style-target');
            updateNodeVisuals(newNode);

            selectedItems.add(newNode.id);
            idMap.set(itemData.originalId, newNode.id); // Mapeia o ID antigo (da cópia) para o novo ID
            pastedNodesData.push(getNodeDataForUndo(newNode));
        });

        // 2. Criar as novas conexões usando o mapa de IDs
        const pastedConnectionsData = [];
        if (appClipboard.connections) {
            appClipboard.connections.forEach(connData => {
                const newFromId = idMap.get(connData.from);
                const newToId = idMap.get(connData.to);

                if (newFromId && newToId) {
                    const newConnection = { ...connData, from: newFromId, to: newToId };
                    connections.push(newConnection);
                    pastedConnectionsData.push(newConnection);
                }
            });
        }

        // 3. Gravar uma única ação de "colar" para o histórico de undo/redo
        if (pastedNodesData.length > 0) {
            recordAction({ type: 'pasteNodes', nodesData: pastedNodesData, connectionsData: pastedConnectionsData });
        }

        updateSelectionVisuals();
        drawLines();
        if (appClipboard.type === 'cut') {
            appClipboard = { type: null, items: [], connections: [], anchor: { left: 0, top: 0 } };
        }
    }

    // --- START: Copy/Paste Formatting Logic ---
    function handleCopyFormatting() {
        if (selectedItems.size !== 1) {
            showModal("Por favor, selecione um único nó para copiar a formatação.");
            return;
        }
        const sourceId = selectedItems.values().next().value;
        const sourceNode = document.getElementById(sourceId);

        if (!sourceNode || !sourceNode.classList.contains('node')) {
             showModal("A cópia de formatação só funciona para nós (itens), não para grupos.");
            return;
        }

        const imageEl = sourceNode.querySelector('img.node-image-content');

        formattingClipboard = {
            width: sourceNode.style.width,
            height: sourceNode.style.height,
            inlineStyle: sourceNode.style.cssText,
            className: sourceNode.className,
            imageStyle: imageEl ? imageEl.style.cssText : null
        };

        showModal("Formatação copiada!");
        const dropdown = copyFormattingBtn.closest('.dropdown-panel');
        if (dropdown) dropdown.classList.add('hidden');
    }

    function handlePasteFormatting() {
        if (!formattingClipboard) {
            showModal("Nenhuma formatação na área de transferência. Use 'Copiar Estilo' primeiro.");
            return;
        }
        if (selectedItems.size === 0) {
            showModal("Por favor, selecione um ou mais nós para aplicar a formatação.");
            return;
        }

        const changes = [];
        selectedItems.forEach(nodeId => {
            const targetNode = document.getElementById(nodeId);
            if (targetNode && targetNode.classList.contains('node')) {
                const oldPosLeft = targetNode.style.left;
                const oldPosTop = targetNode.style.top;

                changes.push({
                    nodeId: nodeId,
                    oldInlineStyle: targetNode.style.cssText,
                    oldClassName: targetNode.className,
                    oldImageStyle: targetNode.querySelector('img.node-image-content')?.style.cssText || null
                });

                targetNode.style.cssText = formattingClipboard.inlineStyle;
                targetNode.className = formattingClipboard.className;

                targetNode.style.left = oldPosLeft;
                targetNode.style.top = oldPosTop;

                const targetImage = targetNode.querySelector('img.node-image-content');
                if (targetImage && formattingClipboard.imageStyle) {
                    targetImage.style.cssText = formattingClipboard.imageStyle;
                }

                updateNodeVisuals(targetNode);
            }
        });

        if (changes.length > 0) {
            recordAction({ type: 'pasteFormatting', changes, newFormatting: { ...formattingClipboard } });
        }

        drawLines();

        const dropdown = pasteFormattingBtn.closest('.dropdown-panel');
        if (dropdown) dropdown.classList.add('hidden');
    }
    // --- END: Copy/Paste Formatting Logic ---

    // --- START: Copy/Paste Text Formatting Logic ---top
    function handleCopyTextFormatting() {
        if (selectedItems.size !== 1) {
            showModal("Por favor, selecione um único item de texto para copiar a formatação.");
            return;
        }
        const sourceId = selectedItems.values().next().value;
        const sourceNode = document.getElementById(sourceId);

        if (!sourceNode || !sourceNode.querySelector('.content')) {
            showModal("A cópia de formatação só funciona para itens com texto.");
            return;
        }

        const contentDiv = sourceNode.querySelector('.content');

        // Usa a nova e robusta função de análise para criar a receita.
        const sequentialRecipe = buildFormatRecipe(contentDiv);

        textFormattingClipboard = {
            isComplex: true,
            recipe: sequentialRecipe,
            lineHeight: contentDiv.style.lineHeight || 'normal'
        };

        showModal("Formatação sequencial copiada!");
        const dropdown = document.getElementById('copyTextFormattingBtn').closest('.dropdown-panel');
        if (dropdown) dropdown.classList.add('hidden');
    }

    function handlePasteTextFormatting() {
        if (!textFormattingClipboard || !textFormattingClipboard.isComplex) {
            showModal("Nenhuma formatação na área de transferência. Use 'Copiar Formatação' primeiro.");
            return;
        }
        if (selectedItems.size === 0) {
            showModal("Por favor, selecione um ou mais nós para aplicar a formatação.");
            return;
        }

        const changes = [];
        const recipe = textFormattingClipboard.recipe;

        selectedItems.forEach(nodeId => {
            const targetNode = document.getElementById(nodeId);
            if (targetNode && targetNode.querySelector('.content')) {
                const contentDiv = targetNode.querySelector('.content');

                const oldState = {
                    innerHTML: contentDiv.innerHTML,
                    lineHeight: contentDiv.style.lineHeight || 'normal'
                };

                // Divide o texto de destino em linhas para mapeamento.
                const targetTextLines = contentDiv.innerText.split('\n');
                let finalHTML = '';
                let textLineIndex = 0;
                // O molde padrão é texto puro.
                let lastFormatTemplate = '%TEXTO%';

                // Itera sobre a receita de formatação da origem.
                recipe.forEach(item => {
                    if (item.type === 'structure') {
                        finalHTML += item.html;
                    } else if (item.type === 'format') {
                        // Armazena o último molde de formatação para o caso de o destino ter mais linhas.
                        lastFormatTemplate = item.template;

                        if (textLineIndex < targetTextLines.length) {
                            const currentText = targetTextLines[textLineIndex] || '';
                            // Preenche o molde com o texto do destino.
                            finalHTML += item.template.replace('%TEXTO%', currentText);
                            textLineIndex++;
                        }
                    }
                });

                // Se sobraram linhas de texto no destino, aplica a última formatação a elas.
                if (textLineIndex < targetTextLines.length) {
                    if (finalHTML !== '' && !finalHTML.endsWith('<br>') && !finalHTML.endsWith('<br/>')) {
                        finalHTML += '<br>';
                    }
                    const remainingLines = targetTextLines.slice(textLineIndex).map(line => {
                        return lastFormatTemplate.replace('%TEXTO%', line || '');
                    });
                    finalHTML += remainingLines.join('<br>');
                }

                contentDiv.innerHTML = finalHTML;
                contentDiv.style.lineHeight = textFormattingClipboard.lineHeight;

                changes.push({
                    nodeId: nodeId,
                    oldState: oldState,
                    newState: {
                        innerHTML: contentDiv.innerHTML,
                        lineHeight: contentDiv.style.lineHeight
                    }
                });
            }
        });

        if (changes.length > 0) {
            recordAction({ type: 'pasteTextFormatting', changes: changes });
        }

        const dropdown = document.getElementById('pasteTextFormattingBtn').closest('.dropdown-panel');
        if (dropdown) dropdown.classList.add('hidden');
    }
    // --- END: Copy/Paste Text Formatting Logic ---

    /**
    * Analisa a estrutura de formatação de um nó de forma recursiva e cria uma receita sequencial.
    * @param {HTMLElement} contentDiv - O elemento .content a ser analisado.
    * @returns {Array<Object>} Uma lista de "moldes" de formatação e estrutura.
    */
    function buildFormatRecipe(contentDiv) {
        const recipe = [];
        if (!contentDiv) return recipe;

        // Função recursiva que navega pela árvore de nós.
        function traverse(node) {
            // Caso 1: É uma quebra de linha <br>, um elemento estrutural.
            if (node.nodeType === Node.ELEMENT_NODE && node.tagName.toUpperCase() === 'BR') {
                recipe.push({ type: 'structure', html: '<br>' });
                return;
            }

            // Caso 2: É um nó de texto com conteúdo. Este é o nosso alvo.
            if (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() !== '') {
                let template = '%TEXTO%';
                let parent = node.parentNode;

                // Sobe pela árvore de pais, do mais interno para o mais externo.
                while (parent && parent !== contentDiv) {
                    // Clona o elemento pai SEM seus filhos (só a tag e atributos).
                    const wrapper = parent.cloneNode(false);
                    // Envolve o molde atual com a nova tag.
                    wrapper.innerHTML = template;
                    template = wrapper.outerHTML;
                    // Sobe para o próximo pai.
                    parent = parent.parentNode;
                }
                recipe.push({ type: 'format', template: template });
                return;
            }

            // Caso 3: É um elemento. Continua a busca recursivamente em seus filhos.
            if (node.nodeType === Node.ELEMENT_NODE) {
                node.childNodes.forEach(child => traverse(child));
            }
        }

        // Inicia a análise a partir do nó de conteúdo.
        contentDiv.childNodes.forEach(child => traverse(child));

        // Se o nó estava totalmente vazio, garante um molde padrão.
        if (recipe.length === 0) {
            recipe.push({ type: 'format', template: '%TEXTO%' });
        }

        return recipe;
    }

    // --- Clipboard & Save/Load ---

    // =========================================================================
    // === INÍCIO DO BLOCO DE CÓDIGO PARA SUBSTITUIÇÃO E ADIÇÃO ================
    // =========================================================================

    // Função para obter os dados do diagrama a serem salvos
    function getDiagramDataAsString() {
        /**
        * Converte um elemento (nó ou grupo) e seus filhos em um objeto para salvar.
        * @param {HTMLElement} element O nó ou grupo a ser serializado.
        * @returns {Object | null}
        */
        function serializeItem(element) {
            if (element.classList.contains('node')) {
                // Reutiliza a função já existente e funcional para serializar nós.
                return getNodeDataForUndo(element);

            } else if (element.classList.contains('group-container')) {
                const groupData = {
                    type: 'group',
                    id: element.id,
                    left: element.style.left,
                    top: element.style.top,
                    width: element.style.width,
                    height: element.style.height,
                    inlineStyle: element.style.cssText,
                    children: []
                };
                // Salva os filhos diretos do grupo de forma recursiva.
                Array.from(element.children).forEach(child => {
                    if (child.classList.contains('node') || child.classList.contains('group-container')) {
                        groupData.children.push(serializeItem(child));
                    }
                });
                return groupData;
            }
            return null;
        }

        // Pega apenas os itens de nível superior no container principal.
        const topLevelItems = Array.from(container.children).filter(el =>
            el.matches('.node:not(.in-group)') || el.classList.contains('group-container')
        );

        const diagramData = {
            // A propriedade "nodes" agora é "items" para refletir a nova estrutura.
            items: topLevelItems.map(serializeItem).filter(Boolean),
            connections: connections,
            nodeCounter: nodeCounter,
            viewport: viewport
        };
        return JSON.stringify(diagramData, null, 2);
    }

    // Função para escrever os dados em um fileHandle
    async function writeToFile(handle, data) {
        const writable = await handle.createWritable();
        await writable.write(data);
        await writable.close();
    }

    // NOVA FUNÇÃO: "Salvar Como..."
    async function handleSaveAsDiagram() {
        // Verifica se a API está disponível
        if (!('showSaveFilePicker' in window)) {
            showModal("Erro: Esta funcionalidade requer um navegador compatível (como Chrome ou Edge) e que a página seja acessada via HTTPS ou um servidor local (localhost). Não funciona abrindo o arquivo HTML diretamente.");
            return;
        }

        try {
            const data = getDiagramDataAsString();
            const newHandle = await window.showSaveFilePicker({
                types: [{
                    description: 'Diagrama JSON',
                    accept: { 'application/json': ['.json'] },
                }],
            });
            await writeToFile(newHandle, data);
            fileHandle = newHandle;
            updateFileInfoBar(fileHandle);
            showModal("Diagrama salvo com sucesso!");
            isDirty = false; 
            return true; 
        } catch (err) {
            if (err.name !== 'AbortError') {
                console.error("Erro ao salvar o diagrama:", err);
                showModal("Não foi possível salvar o diagrama.");
            }
        }
    }

    // FUNÇÃO MODIFICADA: "Salvar"
    async function handleSaveDiagram() {
        // Verifica se a API está disponível no navegador e no ambiente (localhost/https)
        if (!('showSaveFilePicker' in window)) {
            showModal("Erro: Esta funcionalidade requer um navegador compatível (como Chrome ou Edge) e que a página seja acessada via HTTPS ou um servidor local (localhost). Não funciona abrindo o arquivo HTML diretamente.");
            return;
        }

        if (fileHandle) {
            try {
                const data = getDiagramDataAsString();
                await writeToFile(fileHandle, data);
                showModal("Alterações salvas!");
                isDirty = false;
                return true;
            } catch (err) {
                if (err.name === 'NotFoundError') {
                    showModal("Arquivo original não encontrado. Por favor, salve novamente.");
                    fileHandle = null;
                    await handleSaveAsDiagram();
                } else {
                    console.error("Erro ao salvar alterações:", err);
                    showModal("Não foi possível salvar as alterações.");
                }
                return false;
            }
        } else {
            await handleSaveAsDiagram();
        }
    }
    
    // FUNÇÃO "PORTEIRO": Verifica se há alterações antes de carregar
    async function handleLoadDiagram() {
        if (!isDirty) {
            // Se não há alterações, carrega o arquivo diretamente.
            await proceedWithLoading();
        } else {
            // Se há alterações, mostra o modal de confirmação.
            const choice = await showConfirmationModal();
            switch (choice) {
                case 'save':
                    // Tenta salvar primeiro. handleSaveDiagram agora retorna true/false.
                    const savedSuccessfully = await handleSaveDiagram();
                    if (savedSuccessfully) {
                        // Se o salvamento foi bem-sucedido, prossegue para carregar o novo arquivo.
                        await proceedWithLoading();
                    }
                    break;
                case 'discard':
                    // Se o usuário descartar, prossegue para carregar o novo arquivo.
                    await proceedWithLoading();
                    break;
                case 'cancel':
                    // Se o usuário cancelar, não faz nada.
                    break;
            }
        }
    }

    // NOVA FUNÇÃO AUXILIAR: Contém a lógica de carregamento que estava antes em handleLoadDiagram
    async function proceedWithLoading() {
        // Verifica se a API está disponível
        if (!('showOpenFilePicker' in window)) {
            showModal("Erro: Esta funcionalidade requer um navegador compatível (como Chrome ou Edge)...");
            return;
        }

        try {
            const [handle] = await window.showOpenFilePicker({
                types: [{ description: 'Diagrama JSON', accept: { 'application/json': ['.json'] } }],
                multiple: false,
            });

            const permissionStatus = await handle.queryPermission({ mode: 'readwrite' });
            if (permissionStatus !== 'granted') {
                const requestStatus = await handle.requestPermission({ mode: 'readwrite' });
                if (requestStatus !== 'granted') {
                    showModal("Permissão de escrita negada. O arquivo foi carregado em modo de leitura.");
                }
            }

            const file = await handle.getFile();
            const content = await file.text();
            fileHandle = handle;
            updateFileInfoBar(fileHandle);
            const data = JSON.parse(content);

            if (!data.items || !data.connections) {
                showModal('Arquivo de diagrama inválido ou em formato antigo. Tente Importar o arquivo.');
                return;
            }

            // Limpeza do canvas e estado
            undoStack = [];
            redoStack = [];
            updateUndoRedoButtons();
            selectedItems.clear();
            selectedConnections.clear();
            editingNode = null;
            hideToolbar();
            svg.innerHTML = '';
            container.innerHTML = '';
            connections = [];
            viewport = data.viewport || { scale: 1.0, panX: 0, panY: 0 };

            let maxLoadedIdNum = 0;

            function createItemRecursive(itemData, parentElement) {
                if (!itemData) return;
                const idMatch = itemData.id.match(/(?:node|group)-(\d+)/);
                if (idMatch && idMatch[1]) {
                    maxLoadedIdNum = Math.max(maxLoadedIdNum, parseInt(idMatch[1], 10));
                }

                if (itemData.type === 'group') {
                    const group = document.createElement('div');
                    group.id = itemData.id;
                    group.className = 'group-container';
                    Object.assign(group.style, {
                        cssText: itemData.inlineStyle,
                        left: itemData.left,
                        top: itemData.top,
                        width: itemData.width,
                        height: itemData.height
                    });
                    parentElement.appendChild(group);

                    if (itemData.children) {
                        itemData.children.forEach(childData => createItemRecursive(childData, group));
                    }
                } else {
                    const nodeData = itemData;
                    let newNode;
                    let options = { isUndoRedo: true };
                    if (nodeData.type === 'image') {
                        options.type = 'image';
                        options.imageUrl = nodeData.imageUrl;
                        newNode = createNode(null, parseFloat(nodeData.left), parseFloat(nodeData.top), nodeData.id, options);
                        const img = newNode.querySelector('img.node-image-content');
                        if (img && nodeData.imageStyle) img.style.cssText = nodeData.imageStyle;
                    } else {
                        newNode = createNode(nodeData.text, parseFloat(nodeData.left), parseFloat(nodeData.top), nodeData.id, options);
                        const contentDiv = newNode.querySelector('.content');
                        if (contentDiv) {
                            contentDiv.style.textAlign = nodeData.contentTextAlign || 'center';
                            contentDiv.style.lineHeight = nodeData.contentLineHeight || 'normal';
                        }
                        newNode.style.alignItems = nodeData.alignItems || 'center';
                    }
                    newNode.className = 'node ' + nodeData.className;
                    Object.assign(newNode.style, {
                        cssText: nodeData.inlineStyle,
                        left: nodeData.left,
                        top: nodeData.top,
                        width: nodeData.width,
                        height: nodeData.height
                    });
                    if (parentElement !== container) newNode.classList.add('in-group');
                    updateNodeVisuals(newNode);
                    parentElement.appendChild(newNode);
                }
            }

            data.items.forEach(itemData => createItemRecursive(itemData, container));

            connections = data.connections;
            nodeCounter = maxLoadedIdNum + 1;
            applyViewportTransform();
            updateSelectionVisuals();
            isDirty = false; // Estado agora está "limpo" em relação ao novo arquivo.

        } catch (err) {
            if (err.name !== 'AbortError') {
                console.error("Erro ao carregar diagrama:", err);
                showModal('Falha ao carregar o arquivo do diagrama.');
            }
        }
    }
    // =========================================================================
    // === FIM DO BLOCO DE CÓDIGO ==============================================
    // =========================================================================

    // FUNÇÃO PARA ATUALIZAR A BARRA DE INFORMAÇÕES ---
    function updateFileInfoBar(handle) {
        if (handle && handle.name) {
            fileInfoText.textContent = `Editando: ${handle.name}`;
            fileInfoBar.style.display = 'block'; // Mostra a barra
        } else {
            fileInfoText.textContent = '';
            fileInfoBar.style.display = 'none'; // Esconde a barra
        }
    }

    // --- Printing ---
    function getDiagramBounds() { let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; let hasElements = false; document.querySelectorAll('.node, .group-container').forEach(item => { hasElements = true; minX = Math.min(minX, item.offsetLeft); minY = Math.min(minY, item.offsetTop); maxX = Math.max(maxX, item.offsetLeft + item.offsetWidth); maxY = Math.max(maxY, item.offsetTop + item.offsetHeight); }); if (!hasElements) return { x: 0, y: 0, width: A4_WIDTH_PX, height: A4_HEIGHT_PX, isEmpty: true }; const padding = 20; return { x: minX - padding, y: minY - padding, width: (maxX - minX) + 2 * padding, height: (maxY - minY) + 2 * padding, isEmpty: false }; }

    function setupForPrint() {
        originalViewportBeforePrint = { ...viewport };

        const selectedSize = pageSizeSelect.value;
        const selectedOrientation = pageOrientationSelect.value;

        let physicalWidth, physicalHeight;
        let pixelWidth = parseFloat(a4PageGuideRect.getAttribute('width'));
        let pixelHeight = parseFloat(a4PageGuideRect.getAttribute('height'));

        // Define o tamanho físico para a diretiva @page, usando as unidades corretas (mm/in)
        if (selectedSize !== 'custom' && PAGE_SIZES_PHYSICAL[selectedSize]) {
            const physicalDims = PAGE_SIZES_PHYSICAL[selectedSize];
            if (selectedOrientation === 'landscape') {
                physicalWidth = physicalDims.height;
                physicalHeight = physicalDims.width;
            } else {
                physicalWidth = physicalDims.width;
                physicalHeight = physicalDims.height;
            }
            dynamicPrintStyle.innerHTML = `@page { size: ${physicalWidth} ${physicalHeight}; margin: 0 !important; }`;
        } else {
            // Usa pixels como fallback para tamanhos customizados
            dynamicPrintStyle.innerHTML = `@page { size: ${pixelWidth}px ${pixelHeight}px; margin: 0 !important; }`;
        }

        // ✨ ALTERAÇÃO PRINCIPAL: Redimensiona explicitamente os contêineres para o tamanho da página em pixels
        panZoomContainer.style.width = `${pixelWidth}px`;
        panZoomContainer.style.height = `${pixelHeight}px`;
        svgContainer.style.width = `${pixelWidth}px`;
        svgContainer.style.height = `${pixelHeight}px`;
        svg.setAttribute('width', pixelWidth);
        svg.setAttribute('height', pixelHeight);

        // Reseta o zoom e o pan para garantir que o conteúdo comece no canto superior esquerdo
        viewport.scale = 1.0;
        viewport.panX = 0;
        viewport.panY = 0;
        applyViewportTransform();
    }

    function cleanupAfterPrint() {
        dynamicPrintStyle.innerHTML = '';
        panZoomContainer.style.width = '100%';
        panZoomContainer.style.height = '100%';
        svgContainer.style.width = '100%';
        svgContainer.style.height = '100%';
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');

        if (originalViewportBeforePrint) {
            viewport.scale = originalViewportBeforePrint.scale;
            viewport.panX = originalViewportBeforePrint.panX;
            viewport.panY = originalViewportBeforePrint.panY;
            originalViewportBeforePrint = null;
        }
        applyViewportTransform();
    }


    // --- Event Handlers: Mouse, Keyboard, General ---
    function configureToolbarForNodeType(node) {
        const isImageNode = !!node.querySelector('img.node-image-content');

        // Seções de TEXTO são escondidas para nós de imagem
        document.querySelector('[data-toolbar-section="text-format"]').style.display = isImageNode ? 'none' : 'flex';
        document.querySelector('[data-toolbar-section="text-align"]').style.display = isImageNode ? 'none' : 'flex';
        document.querySelector('[data-toolbar-section="vertical-align"]').style.display = isImageNode ? 'none' : 'flex';
        document.querySelector('[data-toolbar-section="text-style"]').style.display = isImageNode ? 'none' : 'flex';
        document.querySelector('[data-toolbar-section="text-color"]').style.display = isImageNode ? 'none' : 'flex';

        // Seção de FUNDO de texto é escondida para nós de imagem
        document.querySelector('[data-toolbar-section="background"]').style.display = isImageNode ? 'none' : 'flex';

        // ✨ CORREÇÃO: O seletor foi atualizado de "border" para "border-color" para corresponder ao novo HTML
        document.querySelector('[data-toolbar-section="border-color"]').style.display = 'flex';
        document.querySelector('[data-toolbar-section="shape"]').style.display = 'flex';

        // Seção de IMAGEM só aparece para nós de imagem
        document.querySelector('[data-toolbar-section="image-style"]').style.display = isImageNode ? 'flex' : 'none';
    }

    // --- Group Context Menu Logic ---
    function hideGroupContextMenu() {
        groupContextMenu.classList.add('hidden');
        manageToolbarPositions();
    }

    function updateGroupContextMenuState(group) {
        if (!group) return;
        const styles = window.getComputedStyle(group);
        groupContextMenu.querySelector('[data-group-style="backgroundColor"]').value = rgbToHex(styles.backgroundColor);
        groupContextMenu.querySelector('[data-group-style="borderColor"]').value = rgbToHex(styles.borderColor);
        groupContextMenu.querySelector('[data-group-style="borderStyle"]').value = styles.borderStyle;
    }

    function applyGroupStyle(styleKey, value) {
        const groupId = groupContextMenu.dataset.targetGroupId;
        if (!groupId) return;
        const group = document.getElementById(groupId);
        if (!group) return;

        let oldValue;
        const isTransparentToggle = styleKey === 'transparent';

        if (isTransparentToggle) {
             oldValue = group.style.backgroundColor;
        } else {
            oldValue = group.style[styleKey];
        }

        const changes = [{
            groupId,
            style: isTransparentToggle ? 'backgroundColor' : styleKey,
            oldValue,
            newValue: isTransparentToggle ? 'transparent' : value
        }];

        if (isTransparentToggle) {
            if (group.style.backgroundColor === 'transparent') {
                const restoredColor = group.dataset.oldBg || themeColors.groupBg;
                changes[0].newValue = restoredColor;
                group.style.backgroundColor = restoredColor;
            } else {
                group.dataset.oldBg = group.style.backgroundColor;
                group.style.backgroundColor = 'transparent';
            }
        } else {
            group.style[styleKey] = value;
        }

        recordAction({ type: 'changeGroupStyles', changes });
    }


    function handleGroupDblClick(e) {
        const group = e.target.closest('.group-container');
        if (group) {
            e.stopPropagation();
            hideMultiSelectToolbar();

            groupContextMenu.classList.remove('hidden');
            groupContextMenu.dataset.targetGroupId = group.id;
            updateGroupContextMenuState(group);
            manageToolbarPositions();
        }
    }

    container.addEventListener('dblclick', handleGroupDblClick);
    contextUngroupBtn.addEventListener('click', () => {
        const targetGroupId = groupContextMenu.dataset.targetGroupId;
        if (targetGroupId) {
            selectedItems.clear();
            selectedItems.add(targetGroupId);
            updateSelectionVisuals();
            handleUngroup();
        }
        hideGroupContextMenu();
    });
    groupContextMenu.addEventListener('change', (e) => {
        const styleKey = e.target.dataset.groupStyle;
        if (styleKey) {
            applyGroupStyle(styleKey, e.target.value);
        }
    });
    groupContextMenu.addEventListener('click', (e) => {
        const button = e.target.closest('button');
        if (button && button.dataset.groupStyle === 'transparent') {
            applyGroupStyle('transparent', null);
        }

        const swatch = e.target.closest('.color-swatch');
        if (swatch) {
            const color = swatch.dataset.color;
            const parentRow = swatch.closest('.context-menu-row');
            const colorInput = parentRow.querySelector('input[type=color]');
            const styleKey = colorInput.dataset.groupStyle;
            colorInput.value = color;
            applyGroupStyle(styleKey, color);
        }
    });

    // --- Novo Listener de Input para Sincronização de Cores no Painel Múltiplo ---
    multiSelectToolbar.addEventListener('input', e => {
        const el = e.target;

        const isValidHex = (hex) => /^#([0-9A-F]{3}){1,2}$/i.test(hex);

        // Se o usuário digitou em um campo de texto de cor...
        if (el.classList.contains('hex-color-input')) {
            const hexValue = el.value.startsWith('#') ? el.value : '#' + el.value;
            if (isValidHex(hexValue)) {
                // Encontra o seletor de cor correspondente e atualiza seu valor
                const style = el.dataset.multiStyleHex;
                const colorInput = multiSelectToolbar.querySelector(`input[data-multi-style="${style}"]`);
                if (colorInput) {
                    colorInput.value = hexValue;
                }
            }
            return;
        }

        // Se o usuário mudou a cor pelo seletor de cor...
        if (el.type === 'color' && el.dataset.multiStyle) {
             const style = el.dataset.multiStyle;
             const hexInput = multiSelectToolbar.querySelector(`input[data-multi-style-hex="${style}"]`);
             if (hexInput) {
                // Atualiza o campo de texto correspondente
                hexInput.value = el.value;
             }
        }
    });

    function handleNodeDblClick(e) {
        e.stopPropagation();
        const node = e.currentTarget;

        if (editingNode && editingNode !== node) {
            finishEditing(editingNode);
        }
        editingNode = node;
        node.classList.add('editing');

        const isImageNode = !!node.querySelector('img.node-image-content');

        if (isImageNode) {
            const imageEl = node.querySelector('img.node-image-content');
            if (imageEl) {
                // Para o Undo, salvamos os estilos tanto do container do nó quanto da imagem
                node.dataset.originalNodeStylesForUndo = node.style.cssText;
                node.dataset.originalImageStylesForUndo = imageEl.style.cssText;
            }
        } else { // type === 'text'
            const contentDiv = node.querySelector('.content');
            contentDiv.contentEditable = true;
            contentDiv.focus();
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(contentDiv);
            selection.removeAllRanges();
            selection.addRange(range);
        }

        configureToolbarForNodeType(node);
        updateToolbarState(node);
        showToolbar(node);
    }

    function finishEditing(node) {
        if (!node) return;

        const isImageNode = !!node.querySelector('img.node-image-content');

        if (isImageNode) {
            const originalNodeStyles = node.dataset.originalNodeStylesForUndo;
            const originalImageStyles = node.dataset.originalImageStylesForUndo;
            const imageEl = node.querySelector('img.node-image-content');

            if (imageEl && typeof originalImageStyles !== 'undefined' && typeof originalNodeStyles !== 'undefined') {
                const newNodeStyles = node.style.cssText;
                const newImageStyles = imageEl.style.cssText;

                // Verifica se houve mudança em qualquer um dos estilos
                if (originalNodeStyles !== newNodeStyles || originalImageStyles !== newImageStyles) {
                    recordAction({
                        type: 'changeImageNodeStyles',
                        nodeId: node.id,
                        oldNodeStyles: originalNodeStyles,
                        oldImageStyles: originalImageStyles,
                        newNodeStyles: newNodeStyles,
                        newImageStyles: newImageStyles
                    });
                }
                delete node.dataset.originalNodeStylesForUndo;
                delete node.dataset.originalImageStylesForUndo;
            }
        } else if (node.querySelector('.content')) {
            const contentDiv = node.querySelector('.content');
            const originalContent = node.dataset.originalContentForUndo;
            const newContent = contentDiv.innerHTML;
            if (originalContent !== newContent) {
                recordAction({ type: 'changeContent', nodeId: node.id, oldContent: originalContent, newContent: newContent });
            }
            delete node.dataset.originalContentForUndo;
            contentDiv.contentEditable = false;
        }

        node.classList.remove('editing');
        if (editingNode === node) {
            editingNode = null;
        }
        hideToolbar();
    }

    function handleNodeBlur(e) {
        setTimeout(() => {
            const focusIsOnToolbar = document.activeElement && toolbar.contains(document.activeElement);
            if (editingNode && !focusIsOnToolbar) {
                finishEditing(editingNode);
            }
        }, 100);
    }

    function handleInteractionEnd(e) {
    if (isPanning) {
        isPanning = false;
        canvasEl.style.cursor = 'default';
        return;
    }

    let actionRecorded = false;

    if (actionState.type === 'dragging' && actionState.moved) {
        alignmentGuidesSvg.innerHTML = ''; // Limpa as guias
        const changes = actionState.initialPositions.map(pos => ({
            nodeId: pos.element.id,
            oldLeft: `${pos.initialLeft}px`,
            oldTop: `${pos.initialTop}px`,
            newLeft: pos.element.style.left,
            newTop: pos.element.style.top
        })).filter(c => c.oldLeft !== c.newLeft || c.oldTop !== c.newTop);

        if (changes.length > 0) {
            recordAction({ type: 'moveNodes', changes: changes });
            actionRecorded = true;
        }
    }
    else if (actionState.type === 'resizing' && actionState.target && actionState.moved) {
        alignmentGuidesSvg.innerHTML = ''; // Limpa as guias
        const node = actionState.target;
        const hasChanged = node.offsetWidth !== actionState.original.width ||
                            node.offsetHeight !== actionState.original.height ||
                            node.offsetLeft !== actionState.original.x ||
                            node.offsetTop !== actionState.original.y;

        if (hasChanged) {
            recordAction({
                type: 'resizeNode',
                nodeId: node.id,
                oldState: {
                    left: `${actionState.original.x}px`,
                    top: `${actionState.original.y}px`,
                    width: `${actionState.original.width}px`,
                    height: `${actionState.original.height}px`
                },
                newState: {
                    left: node.style.left,
                    top: node.style.top,
                    width: node.style.width,
                    height: node.style.height
                }
            });
            actionRecorded = true;
        }
    }
    else if (actionState.type === 'linking' && actionState.target) {
        const snappedEl = document.querySelector('.connector.snap-target');
        if (snappedEl) {
            const from = { id: actionState.target.id, pos: actionState.linkStartPos };
            const to = { id: snappedEl.dataset.nodeId, pos: snappedEl.dataset.position };
            const newConnection = { from: from.id, to: to.id, fromPos: from.pos, toPos: to.pos, color: currentLineColor, width: currentLineStrokeWidth };
            connections.push(newConnection);
            recordAction({ type: 'createConnection', connectionData: newConnection });
            actionRecorded = true;
        }
        if(snappedEl) snappedEl.classList.remove('snap-target');
    }
    else if (actionState.type === 'potential-drag' && !actionState.moved && actionState.target) {
        selectItem(actionState.target, actionState.isCtrl);
        const targetNode = actionState.target.classList.contains('node') ? actionState.target : null;
        if (editingNode && editingNode !== targetNode) {
            finishEditing(editingNode);
        }
    }
    else if (actionState.type === 'marquee') {
        marquee.style.visibility = 'hidden';
        selectNodesInRect(marquee.getBoundingClientRect(), actionState.isCtrl);
    }
    else if (actionState.type === 'potential-marquee' && !actionState.moved) {
        if (!actionState.isCtrl) clearSelection();
        if (editingNode) finishEditing(editingNode);
        else hideToolbar();
    }

    if (actionState.target) actionState.target.classList.remove('dragging');
    actionState = { type: null, target: null, startX: 0, startY: 0, startWidth: 0, startHeight: 0, linkStartPos: null, isCtrl: false, moved: false, initialPositions: [] };
    document.body.style.cursor = 'default';
    drawLines();
}

    // --- Initial Event Listener Setup ---
    window.addEventListener('beforeprint', setupForPrint);
    window.addEventListener('afterprint', cleanupAfterPrint);
    window.addEventListener('mouseleave', (e) => { if (isPanning || actionState.type) handleInteractionEnd(e); });
    fitToContentBtn.addEventListener('click', () => { isA4ModeActive = false; fitToContent(); });
    fitToPageBtn.addEventListener('click', () => { isA4ModeActive = true; fitToA4PageGuide(); });
    zoomInBtnManual.addEventListener('click', () => handleManualZoom(true));
    zoomOutBtnManual.addEventListener('click', () => handleManualZoom(false));
    zoomResetBtnManual.addEventListener('click', resetZoomTo100);

    document.addEventListener('mousedown', e => {
        if (e.button === 1) {
            isPanning = true;
            lastPanPosition = { x: e.clientX, y: e.clientY };
            canvasEl.style.cursor = 'grabbing';
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        // --- LÓGICA DE REDIMENSIONAMENTO (NOVO) ---
        // Verifica se o clique foi em uma das novas alças de redimensionamento
        const resizeHandle = e.target.closest('.resize-handle');
        if (resizeHandle) {
            e.stopPropagation();
            const node = resizeHandle.closest('.node');
            if (node) {
                actionState = {
                    type: 'resizing',
                    target: node,
                    direction: resizeHandle.dataset.direction,
                    startX: e.clientX,
                    startY: e.clientY,
                    // Armazena a posição e dimensões originais no mundo do canvas
                    original: {
                        x: node.offsetLeft,
                        y: node.offsetTop,
                        width: node.offsetWidth,
                        height: node.offsetHeight
                    },
                    moved: false
                };
                document.body.style.cursor = window.getComputedStyle(resizeHandle).cursor;
            }
            return; // Impede que o evento continue e cause um drag do nó
        }

        if (toolbar.contains(e.target) || e.target.closest('#top-buttons-container') || multiSelectToolbar.contains(e.target) || connectionToolbar.contains(e.target) || groupContextMenu.contains(e.target)) {
            return;
        }

        if (!groupContextMenu.classList.contains('hidden') && !groupContextMenu.contains(e.target)) {
            hideGroupContextMenu();
        }

        if (editingNode && !toolbar.contains(e.target) && !editingNode.contains(e.target)) {
            finishEditing(editingNode);
        }
        const clickedConnectionGroup = e.target.closest('g.connection-group');
        if (clickedConnectionGroup) {
            e.stopPropagation();
            if (selectedItems.size > 0) { selectedItems.clear(); updateSelectionVisuals(); }
            const connIndex = parseInt(clickedConnectionGroup.dataset.connIndex, 10);
            const isCtrl = e.ctrlKey || e.metaKey;
            if (!isCtrl) {
                if (!(selectedConnections.has(connIndex) && selectedConnections.size === 1)) {
                    selectedConnections.clear();
                    selectedConnections.add(connIndex);
                }
            } else {
                if (selectedConnections.has(connIndex)) { selectedConnections.delete(connIndex); }
                else { selectedConnections.add(connIndex); }
            }
            drawLines();
            updateSelectionVisuals();
            return;
        }
        const clickedItem = e.target.closest('.node, .group-container');
        let isEditableContentClick = editingNode?.querySelector('.content')?.contains(e.target);
        if (isEditableContentClick) {
            return;
        }
        actionState.startX = e.clientX; actionState.startY = e.clientY; actionState.isCtrl = e.ctrlKey || e.metaKey; actionState.moved = false;
        if (clickedItem) {
            if (selectedConnections.size > 0) { selectedConnections.clear(); drawLines(); updateSelectionVisuals(); }
            const target = e.target;
            if (clickedItem.classList.contains('node') && !clickedItem.classList.contains('in-group')) {
                if (target.classList.contains('connector')) { e.stopPropagation(); actionState = { ...actionState, type: 'linking', target: clickedItem, linkStartPos: target.dataset.position }; document.body.style.cursor = 'crosshair'; }
                else { actionState = { ...actionState, type: 'potential-drag', target: clickedItem }; }
            } else {
                 actionState = { ...actionState, type: 'potential-drag', target: clickedItem.closest('.group-container') || clickedItem };
            }
        } else { actionState.type = 'potential-marquee'; }
    });
    document.addEventListener('mousemove', e => {
        globalScreenMouse = { x: e.clientX, y: e.clientY };
        if (isPanning) {
            const dx = e.clientX - lastPanPosition.x, dy = e.clientY - lastPanPosition.y;
            viewport.panX += dx; viewport.panY += dy;
            lastPanPosition = { x: e.clientX, y: e.clientY };
            applyViewportTransform();
            return;
        }
        if (!actionState.type) return;
        if (!actionState.moved && (Math.abs(e.clientX - actionState.startX) > DRAG_THRESHOLD || Math.abs(e.clientY - actionState.startY) > DRAG_THRESHOLD)) {
            actionState.moved = true;
            if (actionState.type === 'potential-drag' && actionState.target) {
                actionState.type = 'dragging';
                actionState.target.classList.add('dragging');
                document.body.style.cursor = 'grabbing';
                const itemToSelect = actionState.target;
                if (!actionState.isCtrl && !selectedItems.has(itemToSelect.id)) {
                    selectItem(itemToSelect, false);
                }
                const targets = selectedItems.has(itemToSelect.id) ? Array.from(selectedItems).map(id => document.getElementById(id)) : [itemToSelect];
                actionState.initialPositions = targets.filter(Boolean).map(el => ({ element: el, initialLeft: el.offsetLeft, initialTop: el.offsetTop, width: el.offsetWidth, height: el.offsetHeight }));
            } else if (actionState.type === 'potential-marquee') {
                actionState.type = 'marquee';
                marquee.style.visibility = 'visible';
            }
        }
        switch (actionState.type) {
            case 'dragging': { // ✨ BLOCO ATUALIZADO
                const deltaX = (e.clientX - actionState.startX) / viewport.scale;
                const deltaY = (e.clientY - actionState.startY) / viewport.scale;

                // 1. Calcular os limites da seleção inteira na sua posição *potencial*
                let selectionBounds = {
                    minX: Infinity, minY: Infinity,
                    maxX: -Infinity, maxY: -Infinity,
                };
                actionState.initialPositions.forEach(pos => {
                    selectionBounds.minX = Math.min(selectionBounds.minX, pos.initialLeft);
                    selectionBounds.minY = Math.min(selectionBounds.minY, pos.initialTop);
                    selectionBounds.maxX = Math.max(selectionBounds.maxX, pos.initialLeft + pos.width);
                    selectionBounds.maxY = Math.max(selectionBounds.maxY, pos.initialTop + pos.height);
                });

                const potentialRect = {
                    left: selectionBounds.minX + deltaX,
                    top: selectionBounds.minY + deltaY,
                    width: selectionBounds.maxX - selectionBounds.minX,
                    height: selectionBounds.maxY - selectionBounds.minY,
                };

                // 2. Obter os ajustes de snap
                const movingItemIds = new Set(actionState.initialPositions.map(p => p.element.id));
                const snapAdjustments = updateAndDrawAlignmentGuides(potentialRect, movingItemIds, 'move', { x: deltaX, y: deltaY });

                // 3. Aplicar a posição final com o ajuste de snap a todos os nós
                actionState.initialPositions.forEach(pos => {
                    pos.element.style.left = `${pos.initialLeft + deltaX + snapAdjustments.x}px`;
                    pos.element.style.top = `${pos.initialTop + deltaY + snapAdjustments.y}px`;
                });

                updateSelectionVisuals();
                drawLines();
                break;
            }
            case 'resizing':
                if (!actionState.target) break;

                actionState.moved = true;
                const node = actionState.target;
                const original = actionState.original;
                const minWidth = 100, minHeight = 40;

                let deltaX_resize = (e.clientX - actionState.startX) / viewport.scale;
                let deltaY_resize = (e.clientY - actionState.startY) / viewport.scale;

                // --- 1. CALCULAR GEOMETRIA POTENCIAL EM MEMÓRIA ---
                let potentialRect_resize = { left: original.x, top: original.y, width: original.width, height: original.height };

                if (actionState.direction.includes('r')) potentialRect_resize.width = original.width + deltaX_resize;
                if (actionState.direction.includes('l')) { potentialRect_resize.width = original.width - deltaX_resize; potentialRect_resize.left = original.x + deltaX_resize; }
                if (actionState.direction.includes('b')) potentialRect_resize.height = original.height + deltaY_resize;
                if (actionState.direction.includes('t')) { potentialRect_resize.height = original.height - deltaY_resize; potentialRect_resize.top = original.y + deltaY_resize; }

                potentialRect_resize.width = Math.max(minWidth, potentialRect_resize.width);
                potentialRect_resize.height = Math.max(minHeight, potentialRect_resize.height);

                // --- 2. OBTER SNAPS BASEADO NA GEOMETRIA EM MEMÓRIA (AGORA COM AJUSTE) ---
                const movingItemIds_resize = new Set([node.id]);
                const snapAdjustments_resize = updateAndDrawAlignmentGuides(potentialRect_resize, movingItemIds_resize, actionState.direction, { x: deltaX_resize, y: deltaY_resize });

                // --- 3. APLICAR AJUSTES DE SNAP À GEOMETRIA FINAL ---
                let finalRect = { ...potentialRect_resize };
                if (actionState.direction.includes('l')) finalRect.left += snapAdjustments_resize.x;
                if (actionState.direction.includes('r')) finalRect.width += snapAdjustments_resize.x;
                if (actionState.direction.includes('t')) finalRect.top += snapAdjustments_resize.y;
                if (actionState.direction.includes('b')) finalRect.height += snapAdjustments_resize.y;

                // Se o snap ajustou a posição, a dimensão também precisa ser ajustada para o lado oposto não se mover
                if (actionState.direction.includes('l') && snapAdjustments_resize.x !== 0) finalRect.width -= snapAdjustments_resize.x;
                if (actionState.direction.includes('t') && snapAdjustments_resize.y !== 0) finalRect.height -= snapAdjustments_resize.y;

                // --- 4. APLICAR ESTILOS AO NÓ UMA ÚNICA VEZ ---
                finalRect.width = Math.max(minWidth, finalRect.width);
                finalRect.height = Math.max(minHeight, finalRect.height);

                node.style.left = `${finalRect.left}px`;
                node.style.top = `${finalRect.top}px`;
                node.style.width = `${finalRect.width}px`;
                node.style.height = `${finalRect.height}px`;

                drawLines();
                break;
            case 'linking':
                const worldMouseDrag = screenToWorld(e.clientX, e.clientY);
                let snappedConnector = null;
                let minDistance = Infinity;

                const oldSnapTarget = document.querySelector('.connector.snap-target');
                if (oldSnapTarget) oldSnapTarget.classList.remove('snap-target');

                document.querySelectorAll('.connector').forEach(connEl => {
                    const nodeId = connEl.dataset.nodeId;
                    if (nodeId !== actionState.target.id) {
                        const nodeEl = document.getElementById(nodeId);
                        if (nodeEl) {
                            const connPos = getConnectorPosition(nodeEl, connEl.dataset.position);
                            const dx = connPos.x - worldMouseDrag.x;
                            const dy = connPos.y - worldMouseDrag.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < CONNECTOR_SNAP_RADIUS && distance < minDistance) {
                                minDistance = distance;
                                snappedConnector = connEl;
                            }
                        }
                    }
                });

                if (snappedConnector) {
                    snappedConnector.classList.add('snap-target');
                }

                drawLines();
                break;
            case 'marquee':
                const x = Math.min(e.clientX, actionState.startX), y = Math.min(e.clientY, actionState.startY), w = Math.abs(e.clientX - actionState.startX), h = Math.abs(e.clientY - actionState.startY);
                marquee.style.left = `${x}px`;
                marquee.style.top = `${y}px`;
                marquee.style.width = `${w}px`;
                marquee.style.height = `${h}px`;
                break;
        }
        if (actionState.type && !actionState.type.startsWith('potential')) e.preventDefault();
    });
    document.addEventListener('mouseup', handleInteractionEnd);
    document.addEventListener('keydown', e => {
        const activeEl = document.activeElement;
        const isEditingText = activeEl?.closest('.node.editing .content');
        const isInputFocused = ['INPUT', 'SELECT', 'TEXTAREA'].includes(activeEl?.tagName);

        if ((e.ctrlKey || e.metaKey) && !isEditingText) {
            if (e.key.toLowerCase() === 'z') { handleUndo(); e.preventDefault(); return; }
            if (e.key.toLowerCase() === 'y') { handleRedo(); e.preventDefault(); return; }
        }

        if (isEditingText || isInputFocused) {
            if (e.key === 'Escape') {
                if (isEditingText) finishEditing(editingNode);
            } else {
                return;
            }
        }

        if (e.key !== 'Escape' && (activeEl?.closest('.dropdown-panel:not(.hidden)') || activeEl?.closest('.menu-trigger-button')))
            if(!(e.ctrlKey || e.metaKey || ['Delete', 'Backspace', 'Enter'].includes(e.key))) return;

        if (e.ctrlKey || e.metaKey) {
            if (!isEditingText && !isInputFocused) {
                switch (e.key.toLowerCase()) {
                    case 'c': handleCopy(); e.preventDefault(); break;
                    case 'x': handleCut(); e.preventDefault(); break;
                    case 'v': handlePaste(); e.preventDefault(); break;
                    case 'a': e.preventDefault(); selectedItems.clear(); document.querySelectorAll('.node, .group-container').forEach(n => selectedItems.add(n.id)); updateSelectionVisuals(); break;
                    case 'g': e.preventDefault(); if (e.shiftKey) { handleUngroup(); } else { handleGroup(); } break;
                }
            }
        }

        if (selectedItems.size > 0 && !isEditingText && !isInputFocused) {
            // Verifica se a tecla pressionada é uma das setas
            if (e.key.startsWith('Arrow')) {
                e.preventDefault();
                let moved = false;

                // 1. Guarda a posição inicial ANTES do primeiro movimento da sequência
                if (!initialKeyMovePositions) {
                    initialKeyMovePositions = Array.from(selectedItems).map(id => {
                        const el = document.getElementById(id);
                        return el ? { nodeId: id, oldLeft: el.style.left, oldTop: el.style.top } : null;
                    }).filter(Boolean);
                }

                // Limpa o timer anterior para reiniciar a contagem
                clearTimeout(keyMoveUndoTimer);

                // 2. Move os nós selecionados
                switch (e.key) {
                    case 'ArrowUp': selectedItems.forEach(id => { const n = document.getElementById(id); if(n) n.style.top = `${n.offsetTop - KEY_MOVE_STEP}px`; }); moved = true; break;
                    case 'ArrowDown': selectedItems.forEach(id => { const n = document.getElementById(id); if(n) n.style.top = `${n.offsetTop + KEY_MOVE_STEP}px`; }); moved = true; break;
                    case 'ArrowLeft': selectedItems.forEach(id => { const n = document.getElementById(id); if(n) n.style.left = `${n.offsetLeft - KEY_MOVE_STEP}px`; }); moved = true; break;
                    case 'ArrowRight': selectedItems.forEach(id => { const n = document.getElementById(id); if(n) n.style.left = `${n.offsetLeft + KEY_MOVE_STEP}px`; }); moved = true; break;
                }

                if (moved) {
                    updateSelectionVisuals();
                    drawLines();

                    // 3. Define um timer. Se o usuário parar de pressionar as teclas, a ação será gravada.
                    keyMoveUndoTimer = setTimeout(() => {
                        const finalChanges = initialKeyMovePositions.map(pos => {
                            const el = document.getElementById(pos.nodeId);
                            // Compara a posição original com a final
                            return el ? { ...pos, newLeft: el.style.left, newTop: el.style.top } : null;
                        }).filter(Boolean);

                        // Garante que só grava se realmente houve mudança
                        const hasMoved = finalChanges.some(c => c.oldLeft !== c.newLeft || c.oldTop !== c.newTop);

                        if (hasMoved) {
                            recordAction({ type: 'moveNodes', changes: finalChanges });
                        }
                        // Reseta para a próxima sequência de movimentos
                        initialKeyMovePositions = null;
                    }, 500); // Meio segundo de espera
                }
            }
        }


        if (['Delete', 'Backspace'].includes(e.key) && !isEditingText && !isInputFocused) {
            if (selectedItems.size > 0 || selectedConnections.size > 0) { e.preventDefault(); handleDelete(); }
        }

        if (e.key === 'Escape') {
            clearSelection();
            if (editingNode) finishEditing(editingNode); else hideToolbar();
            hideGroupContextMenu();
        }
    });
    document.addEventListener('selectionchange', () => { if (editingNode) { const sel = window.getSelection(); if (sel.rangeCount > 0 && editingNode.querySelector('.content').contains(sel.anchorNode)) savedRange = sel.getRangeAt(0).cloneRange(); } });
    canvasEl.addEventListener('wheel', e => { if (e.ctrlKey) { e.preventDefault(); const rect = canvasEl.getBoundingClientRect(); const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top; const worldX = (mouseX - viewport.panX) / viewport.scale, worldY = (mouseY - viewport.panY) / viewport.scale; const factor = e.deltaY < 0 ? (1 + 0.1) : (1 / (1 + 0.1)); const newScale = Math.max(MIN_ZOOM_SCALE, Math.min(viewport.scale * factor, MAX_ZOOM_SCALE)); viewport.panX = mouseX - worldX * newScale; viewport.panY = mouseY - worldY * newScale; viewport.scale = newScale; applyViewportTransform(); } });

    // --- Page Settings Event Listeners ---
    pageSizeSelect.addEventListener('change', () => { if (pageSizeSelect.value === 'custom') { customSizeInputs.classList.remove('hidden'); } else { customSizeInputs.classList.add('hidden'); } });
    applyPageSettings.addEventListener('click', () => { updatePageGuide(); fitToA4PageGuide(); document.getElementById('page-menu').classList.add('hidden'); });
    addNodeButton.addEventListener('click', () => { let refNode = null; if (selectedItems.size === 1) refNode = document.getElementById(selectedItems.values().next().value); else if (document.querySelectorAll('.node').length > 0) refNode = Array.from(document.querySelectorAll('.node')).reduce((last, curr) => parseInt(curr.id.split('-')[1]) > parseInt(last.id.split('-')[1]) ? curr : last); let newNodeX, newNodeY; if (refNode) { newNodeX = refNode.offsetLeft + refNode.offsetWidth + 20; newNodeY = refNode.offsetTop + 80;; } else { const worldCenter = screenToWorld(canvasEl.clientWidth / 2, canvasEl.clientHeight / 2); newNodeX = worldCenter.x - 50; newNodeY = worldCenter.y - 20; const pageW = a4PageGuideRect.getAttribute('width'); const pageH = a4PageGuideRect.getAttribute('height'); newNodeX = Math.max(20, Math.min(newNodeX, pageW - 120)); newNodeY = Math.max(20, Math.min(newNodeY, pageH - 60)); } const newNode = createNode('Novo Item', newNodeX, newNodeY); clearSelection(); selectedItems.add(newNode.id); updateSelectionVisuals(); });
    printToPDFBtn.addEventListener('click', () => window.print());
    deleteBtn.addEventListener('click', handleDelete);
    copyFormattingBtn.addEventListener('click', handleCopyFormatting);
    pasteFormattingBtn.addEventListener('click', handlePasteFormatting);

    toolbar.addEventListener('mousedown', e => {
        if (e.target.closest('select, input, button')) {
            return;
        }
        e.preventDefault();
    });

    toolbar.addEventListener('click', e => {
        if (e.target.id === 'resetImageStylesBtn') {
            resetImageStyles();
            return;
        }

        const swatch = e.target.closest('.color-swatch');
        if (swatch && editingNode) {
            const palette = swatch.closest('.palette');
            const color = swatch.dataset.color;

            if (palette.id === 'palette-text') {
                applyFormat('foreColor', color);
                document.getElementById('customColor').value = color;
                document.getElementById('customColorHex').value = color; // Sincroniza o campo de texto
            } else if (palette.id === 'palette-bg') {
                applyNodeStyle('backgroundColor', color);
                toolbar.querySelector('input[data-style="backgroundColor"]').value = color;
                toolbar.querySelector('input[data-style-hex="backgroundColor"]').value = color; // Sincroniza
            } else if (palette.id === 'palette-border') {
                applyNodeStyle('borderColor', color);
                toolbar.querySelector('input[data-style="borderColor"]').value = color;
                 toolbar.querySelector('input[data-style-hex="borderColor"]').value = color; // Sincroniza
            }
            return;
        }

        const btn = e.target.closest('button');
        if (btn) {
            const cmd = btn.dataset.cmd;
            const style = btn.dataset.style;
            const textAlign = btn.dataset.textalign;
            const verticalAlign = btn.dataset.verticalalign;

            if (cmd) {
                applyFormat(cmd);
            } else if (textAlign) {
                applyTextAlign(textAlign);
            } else if (verticalAlign) {
                applyVerticalAlign(verticalAlign);
            } else if (style === 'transparent') {
                toggleNodeTransparency();
            }
        }
    });

    toolbar.addEventListener('input', e => {
        const el = e.target;
        if (!editingNode) return;

        // --- LÓGICA DE SINCRONIZAÇÃO DE COR ---
        const isValidHex = (hex) => /^#([0-9A-F]{3}){1,2}$/i.test(hex);

        if (el.classList.contains('hex-color-input')) {
            const hexValue = el.value.startsWith('#') ? el.value : '#' + el.value;
            if (isValidHex(hexValue)) {
                // Sincroniza o <input type="color"> correspondente
                let colorInput;
                if(el.id === 'customColorHex') {
                    colorInput = document.getElementById('customColor');
                } else {
                    const style = el.dataset.styleHex;
                    colorInput = toolbar.querySelector(`input[data-style="${style}"]`);
                }

                if (colorInput) {
                    colorInput.value = hexValue;
                    // Dispara o evento de 'input' no color picker para reusar a lógica de aplicação de estilo
                    colorInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
            return; // Encerra aqui para evitar dupla execução
        }

        // --- LÓGICA EXISTENTE (ADAPTADA) ---
        if (el.closest('[data-toolbar-section="image-style"]')) {
            applyImageStyles();
            return;
        }

        const style = el.dataset.style;
        const cmd = el.dataset.cmd;
        let val = el.value;

        // Sincroniza o campo de texto quando o <input type="color"> muda
        if (el.type === 'color') {
            let hexInput;
            if (el.id === 'customColor') {
                hexInput = document.getElementById('customColorHex');
            } else {
                hexInput = toolbar.querySelector(`input[data-style-hex="${style}"]`);
            }
            if (hexInput) hexInput.value = val;
        }

        // Aplica o estilo
        if (el.id === 'customColor') { // Tratamento especial para cor de texto
             applyFormat('foreColor', val);
        } else if (cmd) {
            applyFormat(cmd, val);
        } else if (style) {
            applyNodeStyle(style, val);
        }

        if (el.tagName === 'SELECT' || el.type === 'color') {
            if (!editingNode.querySelector('img.node-image-content')) {
                editingNode.querySelector('.content').focus();
            }
        }
    });

    // Remove o antigo listener de 'change' para o customColorInput
    // customColorInput.addEventListener('input', e => applyFormat('foreColor', e.target.value));
    // Esta linha não é mais necessária pois a lógica foi incorporada no listener unificado acima.
    customColorInput.addEventListener('input', e => applyFormat('foreColor', e.target.value));

    // --- Listeners do Painel Flutuante ---
    applyBulkChangesBtn.addEventListener('click', applyBulkStyles);
    multiSelectToolbar.addEventListener('click', e => {
        const swatch = e.target.closest('.color-swatch');
        if (swatch) {
            const palette = swatch.closest('.palette');
            const color = swatch.dataset.color;
            let colorInput, hexInput;

            if (palette.id === 'multi-palette-bg') {
                colorInput = multiSelectToolbar.querySelector('input[data-multi-style="backgroundColor"]');
                hexInput = multiSelectToolbar.querySelector('input[data-multi-style-hex="backgroundColor"]');
            } else if (palette.id === 'multi-palette-border') {
                colorInput = multiSelectToolbar.querySelector('input[data-multi-style="borderColor"]');
                hexInput = multiSelectToolbar.querySelector('input[data-multi-style-hex="borderColor"]');
            }

            if(colorInput) colorInput.value = color;
            if(hexInput) hexInput.value = color; // Atualiza também o campo de texto

            return;
        }

        const button = e.target.closest('button');
        if (!button || button.id === 'applyBulkChanges') return;

        const alignType = button.dataset.align;
        const distributeType = button.dataset.distribute;
        const action = button.dataset.action;

        if (alignType) alignSelected(alignType);
        else if (distributeType) distributeSelected(distributeType);
        else if (action === 'group') handleGroup();
        else if (action === 'ungroup') handleUngroup();
    });

    // --- Listeners do Painel de Conexão ---
    connectionToolbar.addEventListener('input', applyConnectionStyles);
    connectionToolbar.addEventListener('click', e => {
        const swatch = e.target.closest('.color-swatch');
        if (swatch) {
            const color = swatch.dataset.color;
            connectionToolbar.querySelector('input[data-conn-style="color"]').value = color;
            applyConnectionStyles();
        }
    });

    // --- Auto-layout Feature ---
    function getNodesForLayout() {
         const nodeElements = selectedItems.size > 0
            ? Array.from(selectedItems).map(id => document.getElementById(id)).filter(el => el && el.classList.contains('node') && !el.classList.contains('in-group'))
            : Array.from(document.querySelectorAll('.node:not(.in-group)'));
        return nodeElements;
    }

    function applyLayout(type) {
        if (isLayoutRunning) return;

        const nodeElements = getNodesForLayout();
        if (nodeElements.length < 2) {
            showModal("Selecione pelo menos dois nós para organizar.");
            return;
        }

        const initialPositions = nodeElements.map(el => ({ nodeId: el.id, oldLeft: el.style.left, oldTop: el.style.top }));

        if (type === 'force') {
            runForceDirectedLayout(nodeElements, initialPositions);
            return;
        }

            let newPositions;
            switch (type) {
                case 'hierarchical-tb': newPositions = calculateHierarchicalLayout(nodeElements, connections); break;
                case 'hierarchical-lr': newPositions = calculateHierarchicalLayout(nodeElements, connections); break;
            }

        if (newPositions) {
            newPositions.forEach(pos => {
                pos.el.style.left = `${pos.x}px`;
                pos.el.style.top = `${pos.y}px`;
            });

            const finalChanges = initialPositions.map(p => ({ ...p, newLeft: document.getElementById(p.nodeId).style.left, newTop: document.getElementById(p.nodeId).style.top }));
            if (finalChanges.length > 0) recordAction({ type: 'moveNodes', changes: finalChanges });
            drawLines();
        }
    }

    function calculateHierarchicalLayout(nodeElements, connections) {
        // --- ETAPA 0: CONFIGURAÇÃO ---
        const verticalGap = 160;
        const horizontalGap = 40;

        // --- ETAPA 1: INICIALIZAÇÃO DOS NÓS ---
        const nodeMap = new Map(nodeElements.map(el => [el.id, {
            el,
            id: el.id,
            children: [],
            parents: [],
            x: 0,
            y: 0,
            width: el.offsetWidth,
            height: el.offsetHeight,
            level: -1,
            isHub: false,
            logicalParent: null,
            logicalChildren: [],
            mod: 0
        }]));

        nodeMap.forEach(node => {
            const isTransparent = node.el.style.backgroundColor === 'transparent';
            const hasNoBorder = !node.el.style.borderWidth || parseInt(node.el.style.borderWidth) === 0;
            if (isTransparent && hasNoBorder) {
                node.isHub = true;
            }
        });

        // --- ETAPA 2: CONSTRUÇÃO DO GRAFO LÓGICO ---
        const hubs = [];
        connections.forEach(conn => {
            const fromNode = nodeMap.get(conn.from);
            const toNode = nodeMap.get(conn.to);
            if (fromNode && toNode) {
                fromNode.children.push(toNode);
                toNode.parents.push(fromNode);
            }
        });

        nodeMap.forEach(node => {
            if (!node.isHub) return;
            hubs.push(node);

            const connectedNodes = [...new Set([...node.parents, ...node.children])];
            const parentNode = connectedNodes.find(n => n.el.offsetTop < node.el.offsetTop && !n.isHub);
            const childNodes = connectedNodes.filter(n => n !== parentNode && !n.isHub);

            if (parentNode && childNodes.length > 0) {
                node.logicalParent = parentNode;
                node.logicalChildren = childNodes;

                parentNode.children = parentNode.children.filter(c => c.id !== node.id);
                childNodes.forEach(child => {
                    child.parents = child.parents.filter(p => p.id !== node.id);
                    if (!parentNode.children.includes(child)) parentNode.children.push(child);
                    if (!child.parents.includes(parentNode)) child.parents.push(parentNode);
                });
            }
        });

        // --- ETAPA 3: ALGORITMO DE LAYOUT (LÓGICA ORIGINAL MANTIDA) ---
        const roots = Array.from(nodeMap.values()).filter(n => !n.isHub && n.parents.filter(p => !p.isHub).length === 0);

        // ✨ INÍCIO DA MODIFICAÇÃO: Captura a posição do nó âncora antes do layout ✨
        let primaryRoot = null;
        let anchorPos = { x: 0, y: 0 };
        if (roots.length > 0) {
            primaryRoot = roots.reduce((acc, root) => {
                if (root.el.offsetTop < acc.el.offsetTop) return root;
                if (root.el.offsetTop === acc.el.offsetTop && root.el.offsetLeft < acc.el.offsetLeft) return root;
                return acc;
            }, roots[0]);
            anchorPos = { x: primaryRoot.el.offsetLeft, y: primaryRoot.el.offsetTop };
        }
        // ✨ FIM DA MODIFICAÇÃO ✨

        // Mantendo seu algoritmo de layout original intacto.
        function firstWalk(node) {
            node.children.forEach(child => {
                if (child.isHub) return;
                firstWalk(child);
            });
            apportion(node);
            if (node.children.length > 0) {
                centerParent(node);
            }
        }
        function apportion(node) {
            const children = node.children.filter(c => !c.isHub);
            if (children.length > 0) {
                let nextX = 0;
                for(const child of children) {
                    child.x = nextX;
                    child.mod = nextX;
                    nextX += child.width + horizontalGap;
                }
            }
        }
        function centerParent(node) {
            const children = node.children.filter(c => !c.isHub);
            if (children.length > 0) {
                const firstChild = children[0];
                const lastChild = children[children.length - 1];
                const childrenWidth = (lastChild.x + lastChild.width) - firstChild.x;
                node.x = firstChild.x + (childrenWidth / 2) - (node.width / 2);
            }
        }
        function secondWalk(node, modifier, level) {
            if (node.isHub) return;
            node.x += modifier;
            node.y = level * verticalGap;
            for (const child of node.children) {
                secondWalk(child, modifier, level + 1);
            }
        }

        roots.forEach(root => {
            firstWalk(root);
            secondWalk(root, 0, 0);
        });

        // --- ETAPA 4: POSICIONAMENTO FINAL DOS HUBS ---
        hubs.forEach(hub => {
            const parent = hub.logicalParent;
            const children = hub.logicalChildren;
            if (parent && children.length > 0) {
                const minChildX = Math.min(...children.map(c => c.x));
                const maxChildX = Math.max(...children.map(c => c.x + c.width));
                const childrenCenterX = minChildX + (maxChildX - minChildX) / 2;
                hub.x = childrenCenterX - (hub.width / 2);
                const parentBottom = parent.y + parent.height;
                const childrenTop = children[0].y;
                const space = childrenTop - parentBottom;
                hub.y = parentBottom + (space / 2) - (hub.height / 2);
            }
        });

        // --- ETAPA 5: MONTAGEM DO RESULTADO FINAL (LÓGICA DE POSICIONAMENTO ALTERADA) ---
        const finalPositions = [];
        let offsetX = 0;
        let offsetY = 0;

        // Se um nó âncora foi encontrado, calcula o deslocamento necessário.
        if (primaryRoot) {
            // A diferença entre a posição original e a calculada é o quanto precisamos mover a árvore.
            offsetX = anchorPos.x - primaryRoot.x;
            offsetY = anchorPos.y - primaryRoot.y;
        } else if (nodeElements.length > 0) {
            // Fallback caso não haja raiz (ex: seleção circular), ancora no primeiro elemento.
            const firstNode = nodeMap.get(nodeElements[0].id);
            if (firstNode) {
                const fallbackAnchorPos = { x: firstNode.el.offsetLeft, y: firstNode.el.offsetTop };
                offsetX = fallbackAnchorPos.x - firstNode.x;
                offsetY = fallbackAnchorPos.y - firstNode.y;
            }
        }

        nodeMap.forEach(node => {
            // Aplica o deslocamento calculado a todos os nós para reposicionar a árvore.
            finalPositions.push({ el: node.el, x: node.x + offsetX, y: node.y + offsetY });
        });

        return finalPositions;
    }


    function runForceDirectedLayout(nodeElements, initialPositions) {
        if (isLayoutRunning) return;
        isLayoutRunning = true;
        const layoutMenu = document.getElementById('layout-menu');
        layoutMenu.querySelectorAll('button').forEach(b => b.disabled = true);
        layoutMenu.querySelector('[data-layout="force"]').innerHTML = '⏳';

        const nodes = nodeElements.map(el => ({
            id: el.id, el,
            x: el.offsetLeft + el.offsetWidth / 2, y: el.offsetTop + el.offsetHeight / 2,
            vx: 0, vy: 0
        }));

        const nodeMap = new Map(nodes.map(n => [n.id, n]));
        const relevantConnections = connections.filter(c => nodeMap.has(c.from) && nodeMap.has(c.to));

        const repulsionStrength = 20000, attractionStrength = 0.04, idealDistance = 220, damping = 0.95;
        let iterations = 150;

        function simulationStep() {
            if (iterations-- <= 0) {
                isLayoutRunning = false;
                layoutMenu.querySelectorAll('button').forEach(b => b.disabled = false);
                layoutMenu.querySelector('[data-layout="force"]').innerHTML = '✨ Força-Dirigida';
                const finalChanges = initialPositions.map(p => ({ ...p, newLeft: document.getElementById(p.nodeId).style.left, newTop: document.getElementById(p.nodeId).style.top })).filter(c => c.oldLeft !== c.newLeft || c.oldTop !== c.newTop);
                if (finalChanges.length > 0) recordAction({ type: 'moveNodes', changes: finalChanges });

                fitToContent();

                return;
            }

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const nodeA = nodes[i], nodeB = nodes[j];
                    const dx = nodeA.x - nodeB.x, dy = nodeA.y - nodeB.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq > 1) {
                        const dist = Math.sqrt(distSq);
                        const force = repulsionStrength / distSq;
                        const fx = (dx / dist) * force, fy = (dy / dist) * force;
                        nodeA.vx += fx; nodeA.vy += fy;
                        nodeB.vx -= fx; nodeB.vy -= fy;
                    }
                }
            }

            for (const conn of relevantConnections) {
                const nodeA = nodeMap.get(conn.from), nodeB = nodeMap.get(conn.to);
                if (nodeA && nodeB) {
                    const dx = nodeB.x - nodeA.x, dy = nodeB.y - nodeA.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const displacement = dist - idealDistance;
                    const force = attractionStrength * displacement;
                    const fx = (dx / dist) * force, fy = (dy / dist) * force;
                    nodeA.vx += fx; nodeA.vy += fy;
                    nodeB.vx -= fx; nodeB.vy -= fy;
                }
            }

            for (const node of nodes) {
                node.vx *= damping; node.vy *= damping;
                node.x += node.vx; node.y += node.vy;
                node.el.style.left = `${node.x - node.el.offsetWidth / 2}px`;
                node.el.style.top = `${node.y - node.el.offsetHeight / 2}px`;
            }

            drawLines();
            requestAnimationFrame(simulationStep);
        }
        requestAnimationFrame(simulationStep);
    }
    document.getElementById('layout-menu').addEventListener('click', (e) => {
        const button = e.target.closest('button[data-layout]');
        if (button) {
            applyLayout(button.dataset.layout);
            button.closest('.dropdown-panel').classList.add('hidden');
        }
    });

    function handleUndo() {
        if (isLayoutRunning || undoStack.length === 0) return;
        const action = undoStack.pop();
        let needsRedraw = false;
        switch (action.type) {
            // ... (todos os outros cases permanecem iguais)
            case 'createNode': document.getElementById(action.nodeId || action.nodeData.id)?.remove(); connections = connections.filter(c => c.from !== (action.nodeId || action.nodeData.id) && c.to !== (action.nodeId || action.nodeData.id)); needsRedraw = true; break;
            case 'deleteNodes': action.nodesData.forEach(nodeData => { const node = createNode(nodeData.text, parseFloat(nodeData.left), parseFloat(nodeData.top), nodeData.id, { isUndoRedo: true }); node.className = 'node ' + nodeData.className; node.style.cssText = nodeData.inlineStyle; node.style.left = nodeData.left; node.style.top = nodeData.top; node.style.width = nodeData.width; node.style.height = nodeData.height; const contentDiv = node.querySelector('.content'); if (contentDiv) { contentDiv.style.textAlign = nodeData.contentTextAlign; contentDiv.style.lineHeight = nodeData.contentLineHeight || 'normal'; } node.style.alignItems = nodeData.alignItems || 'center'; const img = node.querySelector('img.node-image-content'); if (img && nodeData.imageStyle) { img.style.cssText = nodeData.imageStyle; } updateNodeVisuals(node); }); action.connectionsData.forEach(cData => { if (!connections.some(c => c.from === cData.from && c.to === c.to)) { connections.push(cData); } }); needsRedraw = true; break;
            case 'moveNodes': action.changes.forEach(c => { const n = document.getElementById(c.nodeId); if (n) { n.style.left = c.oldLeft; n.style.top = c.oldTop; } }); needsRedraw = true; break;
            case 'resizeNode':
                const nResizeUndo = document.getElementById(action.nodeId);
                if (nResizeUndo) { Object.assign(nResizeUndo.style, action.oldState); }
                needsRedraw = true;
                break;
            case 'createConnection': connections.pop(); needsRedraw = true; break;
            case 'deleteConnections': connections.push(...action.deletedConns); needsRedraw = true; break;
            case 'changeContent': const nContent = document.getElementById(action.nodeId); if (nContent) nContent.querySelector('.content').innerHTML = action.oldContent; break;
            case 'pasteNodes':
                if (action.connectionsData) {
                    const pastedConnSet = new Set(action.connectionsData.map(c => JSON.stringify(c)));
                    connections = connections.filter(c => !pastedConnSet.has(JSON.stringify(c)));
                }
                action.nodesData.forEach(nData => {
                    document.getElementById(nData.id)?.remove();
                });
                needsRedraw = true;
                break;
            case 'changeNodeStyles': action.changes.forEach(change => { const node = document.getElementById(change.nodeId); if (node) { applyStyleToSingleNode(node, change.style, change.oldValue); } }); needsRedraw = true; break;
            case 'bulkChangeNodeStyles': action.changes.forEach(change => { const node = document.getElementById(change.nodeId); if (node) { applyStyleToSingleNode(node, 'backgroundColor', change.oldStyles.backgroundColor); applyStyleToSingleNode(node, 'borderColor', change.oldStyles.borderColor); applyStyleToSingleNode(node, 'borderWidth', parseInt(change.oldStyles.borderWidth) || 0); applyStyleToSingleNode(node, 'shape', change.oldStyles.shape); } }); needsRedraw = true; break;
            case 'changeConnectionStyles': action.changes.forEach(change => { const conn = connections[change.index]; if (conn) { conn.color = change.oldStyles.color; conn.width = change.oldStyles.width; } }); needsRedraw = true; break;
            case 'changeGroupStyles': action.changes.forEach(c => { const g = document.getElementById(c.groupId); if (g) { g.style[c.style] = c.oldValue; } }); break;

            case 'group':
                const groupToUndo = document.getElementById(action.groupId);
                if (groupToUndo) {
                    const itemsToRestore = [];
                    action.groupedItemsData.forEach(data => {
                        const item = document.getElementById(data.id);
                        if(item) itemsToRestore.push(item);
                    });

                    itemsToRestore.forEach(item => {
                        const oldData = action.groupedItemsData.find(d => d.id === item.id);
                        container.appendChild(item);
                        item.style.left = oldData.left;
                        item.style.top = oldData.top;
                        if (item.classList.contains('node')) {
                            item.classList.remove('in-group');
                        }
                    });
                    groupToUndo.remove();
                }
                selectedItems.clear();
                action.groupedItemsData.forEach(data => selectedItems.add(data.id));
                needsRedraw = true;
                break;

            case 'ungroup':
                action.ungroupedData.forEach(data => {
                    const group = document.createElement('div');
                    group.id = data.groupData.id;
                    group.className = 'group-container';
                    Object.assign(group.style, data.groupData);
                    container.appendChild(group);

                    data.childrenData.forEach(childData => {
                        const child = document.getElementById(childData.id);
                        if (child) {
                            group.appendChild(child);
                            child.style.left = childData.left;
                            child.style.top = childData.top;
                            if (child.classList.contains('node')) {
                                child.classList.add('in-group');
                            }
                        }
                    });
                });
                selectedItems.clear();
                action.ungroupedData.forEach(data => selectedItems.add(data.groupData.id));
                needsRedraw = true;
                break;

            case 'changeImageNodeStyles':
                const nodeToUndo = document.getElementById(action.nodeId);
                if (nodeToUndo) {
                    nodeToUndo.style.cssText = action.oldNodeStyles;
                    const img = nodeToUndo.querySelector('img.node-image-content');
                    if (img) img.style.cssText = action.oldImageStyles;
                }
                break;
            case 'pasteFormatting':
                action.changes.forEach(change => {
                    const node = document.getElementById(change.nodeId);
                    if (node) {
                        const oldPosLeft = node.style.left;
                        const oldPosTop = node.style.top;
                        node.style.cssText = change.oldInlineStyle;
                        node.className = change.oldClassName;
                        node.style.left = oldPosLeft;
                        node.style.top = oldPosTop;
                        const image = node.querySelector('img.node-image-content');
                        if (image && change.oldImageStyle) {
                            image.style.cssText = change.oldImageStyle;
                        }
                        updateNodeVisuals(node);
                    }
                });
                needsRedraw = true;
                break;

            // ALTERADO: Lógica de desfazer para a colagem de formatação
            case 'pasteTextFormatting':
                action.changes.forEach(change => {
                    const node = document.getElementById(change.nodeId);
                    if (node && node.querySelector('.content')) {
                        const contentDiv = node.querySelector('.content');
                        const oldState = change.oldState;
                        contentDiv.innerHTML = oldState.innerHTML;
                        contentDiv.style.lineHeight = oldState.lineHeight;
                    }
                });
                break;
        }
        recordAction(action, true, false);
        if (needsRedraw) drawLines();
        updateSelectionVisuals();
    }

    function handleRedo() {
        if (isLayoutRunning || redoStack.length === 0) return;
        const action = redoStack.pop();
        let needsRedraw = false;
        switch (action.type) {
            // ... (todos os outros cases permanecem iguais)
            case 'createNode': case 'pasteNodes':
                const nodesToCreate = action.type === 'createNode' ? [action.nodeData] : action.nodesData;
                nodesToCreate.forEach(nodeData => {
                    const node = createNode(nodeData.text, parseFloat(nodeData.left), parseFloat(nodeData.top), nodeData.id, { isUndoRedo: true });
                    node.className = 'node ' + nodeData.className;
                    node.style.cssText = nodeData.inlineStyle;
                    node.style.left = nodeData.left;
                    node.style.top = nodeData.top;
                    node.style.width = nodeData.width;
                    node.style.height = nodeData.height;
                    const contentDiv = node.querySelector('.content');
                    if (contentDiv) {
                        contentDiv.style.textAlign = nodeData.contentTextAlign;
                        contentDiv.style.lineHeight = nodeData.contentLineHeight || 'normal';
                    }
                    node.style.alignItems = nodeData.alignItems || 'center';
                    const img = node.querySelector('img.node-image-content');
                    if (img && nodeData.imageStyle) {
                        img.style.cssText = nodeData.imageStyle;
                    }
                    updateNodeVisuals(node);
                });
                if (action.type === 'pasteNodes' && action.connectionsData) {
                    connections.push(...action.connectionsData);
                }
                needsRedraw = true;
                break;
            case 'deleteNodes': action.nodesData.forEach(nData => { document.getElementById(nData.id)?.remove(); }); const nodesToFilter = new Set(action.nodesData.map(nd => nd.id)); connections = connections.filter(c => !nodesToFilter.has(c.from) && !nodesToFilter.has(c.to)); selectedItems.clear(); needsRedraw = true; break;
            case 'moveNodes': action.changes.forEach(c => { const n = document.getElementById(c.nodeId); if (n) { n.style.left = c.newLeft; n.style.top = c.newTop; } }); needsRedraw = true; break;
            case 'resizeNode':
                const nResizeRedo = document.getElementById(action.nodeId);
                if (nResizeRedo) { Object.assign(nResizeRedo.style, action.newState); }
                needsRedraw = true;
                break;
            case 'createConnection': if (action.connectionData) connections.push(action.connectionData); needsRedraw = true; break;
            case 'deleteConnections': const connsToRedoDelete = new Set(action.deletedConns.map(c => JSON.stringify(c))); connections = connections.filter(c => !connsToRedoDelete.has(JSON.stringify(c))); selectedConnections.clear(); needsRedraw = true; break;
            case 'changeContent': const nContent = document.getElementById(action.nodeId); if (nContent) nContent.querySelector('.content').innerHTML = action.newContent; break;
            case 'changeNodeStyles': action.changes.forEach(change => { const node = document.getElementById(change.nodeId); if (node) { applyStyleToSingleNode(node, change.style, change.newValue); } }); needsRedraw = true; break;
            case 'bulkChangeNodeStyles': action.changes.forEach(change => { const node = document.getElementById(change.nodeId); if (node) { applyStyleToSingleNode(node, 'backgroundColor', action.newStyles.backgroundColor); applyStyleToSingleNode(node, 'borderColor', action.newStyles.borderColor); applyStyleToSingleNode(node, 'borderWidth', action.newStyles.borderWidth); applyStyleToSingleNode(node, 'shape', action.newStyles.shape); } }); needsRedraw = true; break;
            case 'changeConnectionStyles': action.changes.forEach(change => { const conn = connections[change.index]; if (conn) { conn.color = action.newStyles.color; conn.width = action.newStyles.width; } }); needsRedraw = true; break;
            case 'changeGroupStyles': action.changes.forEach(c => { const g = document.getElementById(c.groupId); if (g) { g.style[c.style] = c.newValue; } }); break;

            case 'group':
                const groupContainer = document.createElement('div');
                groupContainer.id = action.groupId;
                groupContainer.className = 'group-container';
                Object.assign(groupContainer.style, action.groupRect);
                container.appendChild(groupContainer);
                const groupLeft = parseFloat(action.groupRect.left);
                const groupTop = parseFloat(action.groupRect.top);

                action.groupedItemsData.forEach(data => {
                    const item = document.getElementById(data.id);
                    if (item) {
                        groupContainer.appendChild(item);
                        item.style.left = `${parseFloat(data.left) - groupLeft}px`;
                        item.style.top = `${parseFloat(data.top) - groupTop}px`;
                        if(item.classList.contains('node')) item.classList.add('in-group');
                    }
                });
                selectedItems.clear();
                selectedItems.add(action.groupId);
                needsRedraw = true;
                break;

            case 'ungroup':
                const allUngroupedIds = new Set();
                action.ungroupedData.forEach(data => {
                    const groupToRedoUngroup = document.getElementById(data.groupData.id);
                    if (groupToRedoUngroup) {
                        const groupAbsPos = getAbsolutePosition(groupToRedoUngroup);
                        const childrenToMove = Array.from(groupToRedoUngroup.children);

                        childrenToMove.forEach(child => {
                            const oldChildData = data.childrenData.find(c => c.id === child.id);
                            if (oldChildData) {
                                const newLeft = groupAbsPos.x + parseFloat(oldChildData.left);
                                const newTop = groupAbsPos.y + parseFloat(oldChildData.top);
                                container.appendChild(child);
                                child.style.left = `${newLeft}px`;
                                child.style.top = `${newTop}px`;
                                if(child.classList.contains('node')) child.classList.remove('in-group');
                                allUngroupedIds.add(child.id);
                            }
                        });
                        groupToRedoUngroup.remove();
                    }
                });
                selectedItems.clear();
                allUngroupedIds.forEach(id => selectedItems.add(id));
                needsRedraw = true;
                break;

            case 'changeImageNodeStyles':
                const nodeToRedo = document.getElementById(action.nodeId);
                if (nodeToRedo) {
                    nodeToRedo.style.cssText = action.newNodeStyles;
                    const img = nodeToRedo.querySelector('img.node-image-content');
                    if (img) img.style.cssText = action.newImageStyles;
                }
                break;
            case 'pasteFormatting':
                action.changes.forEach(change => {
                    const node = document.getElementById(change.nodeId);
                    if (node) {
                        const oldPosLeft = node.style.left;
                        const oldPosTop = node.style.top;
                        node.style.cssText = action.newFormatting.inlineStyle;
                        node.className = action.newFormatting.className;
                        node.style.left = oldPosLeft;
                        node.style.top = oldPosTop;
                        const image = node.querySelector('img.node-image-content');
                        if (image && action.newFormatting.imageStyle) {
                            image.style.cssText = action.newFormatting.imageStyle;
                        }
                        updateNodeVisuals(node);
                    }
                });
                needsRedraw = true;
                break;

            // ALTERADO: Lógica de refazer para a colagem de formatação
            case 'pasteTextFormatting':
                action.changes.forEach(change => {
                    const node = document.getElementById(change.nodeId);
                    if (node && node.querySelector('.content')) {
                        const contentDiv = node.querySelector('.content');
                        const newState = change.newState;
                        contentDiv.innerHTML = newState.innerHTML;
                        contentDiv.style.lineHeight = newState.lineHeight;
                    }
                });
                break;
        }
        recordAction(action, false, true);
        if (needsRedraw) drawLines();
        updateSelectionVisuals();
    }
    undoBtn.addEventListener('click', handleUndo);
    redoBtn.addEventListener('click', handleRedo);

    // --- Initialization ---
    function applyTheme() {
        const root = document.documentElement;
        root.style.setProperty('--color-primary-accent', themeColors.primaryAccent);
        root.style.setProperty('--color-selection', themeColors.selection);
        root.style.setProperty('--color-connection', themeColors.connection);
        root.style.setProperty('--color-group-border', themeColors.groupBorder);
        root.style.setProperty('--color-group-bg', themeColors.groupBg);
        root.style.setProperty('--color-node-border-editing', themeColors.nodeBorderEditing);
    }

    function handleImageUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const imageUrl = e.target.result;
            const newNode = createNode(null, 150, 150, null, { type: 'image', imageUrl: imageUrl });
            clearSelection();
            selectedItems.add(newNode.id);
            updateSelectionVisuals();
        };
        reader.readAsDataURL(file);

        event.target.value = null;
    }

    function handleImportDiagram(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (!data.nodes || !data.connections) {
                    showModal('Arquivo de diagrama inválido ou mal formatado.');
                    return;
                }

                // Não limpa o canvas, apenas adiciona.
                clearSelection();

                const idMap = new Map();
                const pastedNodesData = [];
                const pastedConnectionsData = [];
                const newSelectedIds = new Set();

                if (data.nodes.length === 0) return;

                // Calcula um ponto de inserção centralizado na visão atual
                const worldCenter = screenToWorld(canvasEl.clientWidth / 2, canvasEl.clientHeight / 2);
                let minX = Infinity, minY = Infinity;
                data.nodes.forEach(nodeData => {
                    minX = Math.min(minX, parseFloat(nodeData.left));
                    minY = Math.min(minY, parseFloat(nodeData.top));
                });

                const offsetX = worldCenter.x - minX;
                const offsetY = worldCenter.y - minY;


                // 1. Criar os novos nós, remapeando os IDs para evitar conflitos
                data.nodes.forEach(nodeData => {
                    const oldId = nodeData.id;
                    const newId = 'node-' + nodeCounter++;
                    idMap.set(oldId, newId);

                    const newX = parseFloat(nodeData.left) + offsetX;
                    const newY = parseFloat(nodeData.top) + offsetY;

                    let newNode;
                    let options = { isUndoRedo: true, recordUndo: false }; // a ação de undo será gravada em lote

                    if (nodeData.type === 'image') {
                        options.type = 'image';
                        options.imageUrl = nodeData.imageUrl;
                        newNode = createNode(null, newX, newY, newId, options);
                        const img = newNode.querySelector('img.node-image-content');
                        if (img && nodeData.imageStyle) {
                            img.style.cssText = nodeData.imageStyle;
                        }
                    } else {
                        newNode = createNode(nodeData.text, newX, newY, newId, options);
                        const contentDiv = newNode.querySelector('.content');
                        if (contentDiv) {
                            contentDiv.style.textAlign = nodeData.contentTextAlign || 'center';
                            contentDiv.style.lineHeight = nodeData.contentLineHeight || 'normal';
                        }
                        newNode.style.alignItems = nodeData.alignItems || 'center';
                    }

                    newNode.className = 'node ' + nodeData.className;
                    newNode.style.cssText = nodeData.inlineStyle;
                    newNode.style.left = `${newX}px`;
                    newNode.style.top = `${newY}px`;
                    newNode.style.width = nodeData.width;
                    newNode.style.height = nodeData.height;
                    updateNodeVisuals(newNode);

                    newSelectedIds.add(newId);
                    pastedNodesData.push(getNodeDataForUndo(newNode));
                });

                // 2. Criar as novas conexões usando o mapa de IDs
                data.connections.forEach(connData => {
                    const newFromId = idMap.get(connData.from);
                    const newToId = idMap.get(connData.to);

                    if (newFromId && newToId) {
                        const newConnection = { ...connData, from: newFromId, to: newToId };
                        connections.push(newConnection);
                        pastedConnectionsData.push(newConnection);
                    }
                });

                // 3. Grava uma única ação de "colar" para o histórico, reutilizando a lógica existente
                if (pastedNodesData.length > 0) {
                    recordAction({ type: 'pasteNodes', nodesData: pastedNodesData, connectionsData: pastedConnectionsData });
                }

                // 4. Atualiza a UI
                selectedItems = newSelectedIds;
                updateSelectionVisuals();
                drawLines();

            } catch (err) {
                console.error("Erro ao importar diagrama:", err);
                showModal('Falha ao importar o arquivo do diagrama.');
            } finally {
                 // Limpa o valor do input para permitir importar o mesmo arquivo novamente
                event.target.value = null;
            }
        };
        reader.readAsText(file);
    }

    function exportToPng() {
        const exportButton = document.getElementById('exportToPNGBtn');
        if (!exportButton) return;
        
        const originalButtonContent = exportButton.innerHTML;
        const diagramContainer = document.getElementById('container');
        const svgLinesContainer = document.getElementById('lines');

        if (diagramContainer.children.length === 0) {
            showModal("Não há nada para exportar!");
            return;
        }

        exportButton.disabled = true;
        exportButton.innerHTML = 'Renderizando...';
        const dropdown = exportButton.closest('.dropdown-panel');
        if (dropdown) dropdown.classList.add('hidden');

        let allCss = "";
        for (const sheet of document.styleSheets) {
            try {
                for (const rule of sheet.cssRules) {
                    allCss += rule.cssText;
                }
            } catch (e) {
                console.warn("Não foi possível ler as regras de CSS, continuando...");
            }
        }
        
        const nodesHtml = diagramContainer.innerHTML;
        const linesSvgHtml = svgLinesContainer.innerHTML;
        const bounds = getDiagramBounds();

        const fullHtmlPayload = `
            <!DOCTYPE html>
            <html lang="pt-BR">
            <head>
                <meta charset="UTF-8">
                <script src="https://cdn.tailwindcss.com"><\/script>
                <style>${allCss}</style>
            </head>
            <body style="background-color: transparent; margin: 0; padding: 0;">
                <div id="diagram-wrapper" style="position: relative; width: ${bounds.width}px; height: ${bounds.height}px; top: 0; left: 0;">
                    <div id="container" style="position: absolute; top: ${-bounds.y}px; left: ${-bounds.x}px;">
                        ${nodesHtml}
                    </div>
                    <svg id="lines" width="${bounds.width}" height="${bounds.height}" style="position: absolute; top: ${-bounds.y}px; left: ${-bounds.x}px; overflow: visible !important;">
                        ${linesSvgHtml}
                    </svg>
                </div>
            </body>
            </html>
        `;

        fetch('/export', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ htmlContent: fullHtmlPayload }),
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(err => { throw new Error(err.error || `Servidor respondeu com erro ${response.status}`); });
            }
            return response.json();
        })
        .then(data => {
            const a = document.createElement('a');
            a.href = `data:image/png;base64,${data.image}`;
            a.download = 'diagrama.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        })
        .catch(error => {
            console.error('Erro ao exportar:', error);
            showModal(`Falha ao exportar a imagem: ${error.message}`);
        })
        .finally(() => {
            exportButton.disabled = false;
            exportButton.innerHTML = originalButtonContent;
        });
    }

    /**
     * Mede a largura de um texto com um estilo específico.
     */
    function measureTextWidth(text, style) {
        textMeasurer.style.font = style.font;
        textMeasurer.textContent = text;
        return textMeasurer.offsetWidth;
    }

    /**
     * Função auxiliar que percorre a árvore de nós e extrai texto e elementos
     * em uma lista plana, preservando a ordem.
     */
    function processNodeForWrapping(contentNode, list) {
        Array.from(contentNode.childNodes).forEach(child => {
            if (child.nodeType === Node.ELEMENT_NODE) {
                if (child.tagName === 'BR') {
                    list.push({ type: 'break' });
                } else {
                    // Entra no elemento para processar seus filhos
                    processNodeForWrapping(child, list);
                }
            } else if (child.nodeType === Node.TEXT_NODE && child.nodeValue.trim() !== '') {
                list.push({ type: 'text', node: child });
            }
        });
    }

    // ==========INICIO DO CONTA-GOTAS (EYEDROPPER) ---

    // Pega as referências dos elementos
    const colorLoupe = document.getElementById('colorLoupe');
    const loupeCanvas = document.getElementById('loupeCanvas');
    const loupeContext = loupeCanvas.getContext('2d');
    const colorPickerModalOverlay = document.getElementById('color-picker-modal-overlay');
    const modalColorPreview = document.getElementById('modalColorPreview');
    const modalColorHexCode = document.getElementById('modalColorHexCode');

    function activateEyedropper() {
        document.body.style.cursor = 'wait';

        html2canvas(canvasEl, { useCORS: true, logging: false, scrollX: -window.scrollX, scrollY: -window.scrollY, windowWidth: document.documentElement.offsetWidth, windowHeight: document.documentElement.offsetHeight })
        .then(canvas => {
            document.body.style.cursor = 'crosshair';
            colorLoupe.style.display = 'block';
            const context = canvas.getContext('2d', { willReadFrequently: true });

            const onMouseMove = (event) => {
                const loupeSize = colorLoupe.offsetWidth;
                const magnification = 4;
                const canvasRect = canvasEl.getBoundingClientRect();
                const mouseX = event.clientX;
                const mouseY = event.clientY;

                colorLoupe.style.left = `${mouseX - loupeSize / 2}px`;
                colorLoupe.style.top = `${mouseY - loupeSize / 2}px`;

                const sourceX = mouseX - canvasRect.left;
                const sourceY = mouseY - canvasRect.top;
                const sourceSize = loupeSize / magnification;

                loupeContext.imageSmoothingEnabled = false;
                loupeContext.clearRect(0, 0, loupeCanvas.width, loupeCanvas.height);
                loupeContext.drawImage(canvas, sourceX - (sourceSize / 2), sourceY - (sourceSize / 2), sourceSize, sourceSize, 0, 0, loupeCanvas.width, loupeCanvas.height);
            };

            const onCanvasClick = (event) => {
                event.stopPropagation();
                event.preventDefault();

                const canvasRect = canvasEl.getBoundingClientRect();
                const x = event.clientX - canvasRect.left;
                const y = event.clientY - canvasRect.top;
                const pixelData = context.getImageData(x, y, 1, 1).data;
                const rgbString = `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;
                const hexColor = rgbToHex(rgbString);

                // --- LÓGICA ATUALIZADA ---
                // Em vez de atualizar os elementos antigos, agora exibimos o modal
                modalColorPreview.style.backgroundColor = hexColor;
                modalColorHexCode.textContent = hexColor;
                colorPickerModalOverlay.style.display = 'flex'; // Mostra o modal

                // --- LIMPEZA ---
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('click', onCanvasClick, { capture: true });
                document.body.style.cursor = 'default';
                colorLoupe.style.display = 'none';
            };

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onCanvasClick, { capture: true });

        }).catch(err => {
            console.error("Erro ao ativar o conta-gotas:", err);
            document.body.style.cursor = 'default';
        });
    }

    // Conecta a função ao botão do conta-gotas
    eyedropperBtn.addEventListener('click', activateEyedropper);

    // --- LÓGICA PARA O NOVO MODAL DE COR ---
    colorPickerModalOverlay.addEventListener('click', (event) => {
        // Fecha o modal se o clique for no fundo (overlay) e não na caixa de conteúdo
        if (event.target === colorPickerModalOverlay) {
            colorPickerModalOverlay.style.display = 'none';
        }
    });

    modalColorHexCode.addEventListener('click', () => {
        const hexValue = modalColorHexCode.textContent;
        navigator.clipboard.writeText(hexValue).then(() => {
            const originalText = modalColorHexCode.textContent;
            modalColorHexCode.textContent = 'Copiado!';
            modalColorHexCode.style.cursor = 'default';
            setTimeout(() => {
                modalColorHexCode.textContent = originalText;
                modalColorHexCode.style.cursor = 'pointer';
            }, 1500);
        }).catch(err => {
            console.error('Falha ao copiar o texto: ', err);
        });
    });

    //=======Fim conta gotas========

    function initialize() {
        // --- Lógica de inicialização existente (permanece a mesma) ---
        applyTheme();
        updateUndoRedoButtons();
        isA4ModeActive = true;
        viewport.scale = 1.0;
        viewport.panX = (canvasEl.clientWidth > A4_WIDTH_PX) ? (canvasEl.clientWidth / 2) - (A4_WIDTH_PX / 2) : A4_VIEW_PADDING;
        viewport.panY = A4_VIEW_PADDING;
        updatePageGuide();
        applyViewportTransform();

        makeDraggable(toolbar, document.getElementById('toolbar-header'));
        makeDraggable(multiSelectToolbar, document.getElementById('multi-select-toolbar-header'));
        makeDraggable(groupContextMenu, document.getElementById('group-context-header'));
        makeDraggable(connectionToolbar, document.getElementById('connection-toolbar-header'));

        // --- Listeners de eventos existentes (permanecem os mesmos) ---
        addImageBtn.addEventListener('click', () => imageUploadInput.click());
        imageUploadInput.addEventListener('change', handleImageUpload);
        
        const importDiagramInput = document.getElementById('importDiagramInput');
        if (importDiagramInput) {
            importDiagramInput.addEventListener('change', handleImportDiagram);
        }

        document.getElementById('copyFormattingBtn').addEventListener('click', handleCopyFormatting);
        document.getElementById('pasteFormattingBtn').addEventListener('click', handlePasteFormatting);
        document.getElementById('copyTextFormattingBtn').addEventListener('click', handleCopyTextFormatting);
        document.getElementById('pasteTextFormattingBtn').addEventListener('click', handlePasteTextFormatting);
        
        const exportToPNGBtn = document.getElementById('exportToPNGBtn');
        if(exportToPNGBtn) {
            exportToPNGBtn.addEventListener('click', exportToPng);
        }

        // 1. Conecta os botões de Salvar, Salvar Como e Carregar às novas funções
        document.getElementById('saveDiagram').addEventListener('click', handleSaveDiagram);
        document.getElementById('saveAsDiagram').addEventListener('click', handleSaveAsDiagram);
        document.getElementById('loadDiagramLabel').addEventListener('click', handleLoadDiagram);

        // 2. Adiciona o atalho de teclado para salvar (Ctrl+S)
        document.addEventListener('keydown', e => {
            // Verifica se a tecla 's' foi pressionada junto com Ctrl (ou Cmd no Mac)
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
                e.preventDefault(); // Impede a ação padrão do navegador (que é salvar a página)
                handleSaveDiagram(); // Chama sua nova função de salvamento rápido
            }
        });

        // 3. Lógica atualizada para fechar o menu "Arquivo" ao clicar em um item.
        //    Isso garante que os novos botões também fechem o menu.
        const fileMenuItems = [
            document.getElementById('saveDiagram'),
            document.getElementById('saveAsDiagram'), // Adicionado
            document.getElementById('loadDiagramLabel'), // Adicionado
            document.querySelector('label[for="importDiagramInput"]'),
            document.getElementById('printToPDFBtn'),
            document.getElementById('exportToPNGBtn')
        ];

        fileMenuItems.forEach(item => {
            if (item) {
                item.addEventListener('click', () => {
                    const panel = item.closest('.dropdown-panel');
                    if (panel) {
                        panel.classList.add('hidden');
                    }
                });
            }
        });
        
        // AVISO ANTES DE SAIR DA PÁGINA
        window.addEventListener('beforeunload', (e) => {
            if (isDirty) {
                // Necessário para acionar o prompt do navegador.
                e.preventDefault();
                // A mensagem customizada não é mais suportada pelos navegadores,
                // mas 'returnValue' é necessário para compatibilidade.
                e.returnValue = '';
            }
        });
    }
    initialize();
  </script>
</body>
</html>
